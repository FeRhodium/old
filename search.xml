<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CCPC 2021 Harbin G Damaged Bicycle</title>
    <url>/ccpc-2021-harbin-g-solution/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定 $n$ 个点 $m$ 条边的带权（长度）无向图，图中有 $k$ 个点，其中第 $i$ 个点有一辆自行车，有 $p_i$ 的概率损坏，只有到达该点才知道自行车是否损坏。</p>
<p>已知 Bessie 的步行速度为 $t$，骑车速度为 $r$，现在她从 $1$ 号点出发，求出一种路径方案，使得期望时间最短。</p>
<p>$1\le n,m\le 10^5$，$k\le 18$。</p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先不难发现，除节点 $1$、节点 $n$ 和其他 $k$ 个节点之外都是无用的，可以做 $k + 1$ 遍最短路求出这些点之间的距离的距离。</p>
<p>注意到 $k$ 很小，套路考虑状压 DP，$S$ 表示当前经过的自行车点的集合，则每次转移需要从集合中的一个点到集合外的点，可以设 $f(S, i)$ 表示当前集合为 $S$，在节点 $i$ 的从 $1$ 到 $i$ 的最小期望长度，其中要考虑要么全部损坏，或是其中一次拿到自行车并直接走到 $n$。则有转移<br>$$<br>f(S\cup\{j\}, j)=\min_{i\in S\land j\not\in S}\left\{f(S, i)+\prod_{k\in S} p_k\left(\frac{\delta(i,j)}t+\frac{(1-p_j)\delta(j,n)}{r}\right)\right\}<br>$$<br>其中，初值为 $f(\{i\},i)=\dfrac{\delta(1,i)}t+\dfrac{(1-p_i)\delta(i,n)}r$。</p>
<p>答案即为 $\min\limits_{i\in S}\left\{f(S, i)+\prod\limits_{j\in S}p_j\dfrac{\delta(i, n)}t\right\}$。</p>
<p>时间复杂度 $O(kn\log m+2^kk^2)$，可以用 $\text{lowbit}$ 优化常数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, tt, rr, kk;</span><br><span class="line">cin &gt;&gt; tt &gt;&gt; rr &gt;&gt; n &gt;&gt; m;</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">e</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u, v, w; m--;) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    e[u].<span class="built_in">emplace_back</span>(v, w);</span><br><span class="line">    e[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> Dijkstra = [&amp;](<span class="keyword">int</span> s) &#123;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; <span class="built_in">vis</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, INT32_MAX / <span class="number">2</span>)</span></span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[v, w] : e[u])</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;-dis[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;;</span><br><span class="line">cin &gt;&gt; kk;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">cycle</span>(kk);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : cycle) cin &gt;&gt; c.first &gt;&gt; c.second;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dis</span>(kk);</span><br><span class="line">dis[<span class="number">0</span>] = <span class="built_in">Dijkstra</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (dis[<span class="number">0</span>][n] == INT32_MAX / <span class="number">2</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>, <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> ans = dis[<span class="number">0</span>][n] * <span class="number">1.0</span> / tt;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt; <span class="built_in">f</span>(<span class="number">1</span> &lt;&lt; kk, vector&lt;<span class="keyword">double</span>&gt;(kk, <span class="number">1e18</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kk; ++i) dis[i] = <span class="built_in">Dijkstra</span>(cycle[i].first);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kk; ++i)</span><br><span class="line">    f[<span class="number">1</span> &lt;&lt; i][i] = <span class="number">1.0</span> * dis[i][<span class="number">1</span>] / tt + <span class="number">0.01</span> * (<span class="number">100</span> - cycle[i].second) * dis[i][n] / rr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; kk); ++i) &#123;</span><br><span class="line">    <span class="keyword">double</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; kk; ++j)</span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) cur *= cycle[j].second * <span class="number">0.01</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; kk; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; (i &gt;&gt; j &amp; <span class="number">1</span>) &amp;&amp; k &lt; kk; ++k)</span><br><span class="line">            <span class="keyword">if</span> (~i &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                f[i | (<span class="number">1</span> &lt;&lt; k)][k] = <span class="built_in">min</span>(f[i | (<span class="number">1</span> &lt;&lt; k)][k], f[i][j] + cur * (<span class="number">1.0</span> * dis[j][cycle[k].first] / tt + <span class="number">0.01</span> * dis[k][n] * (<span class="number">100</span> - cycle[k].second) / rr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; kk); ++i) &#123;</span><br><span class="line">    <span class="keyword">double</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; kk; ++j)</span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) cur *= cycle[j].second * <span class="number">0.01</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; kk; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) ans = <span class="built_in">min</span>(ans, f[i][j] + cur * dis[j][n] / tt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.7lf&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>CodeForces Global Round 2 H</title>
    <url>/cf-1119h/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定 $n$ 个可重集 $S_i$ 及 $x,y,z,k$，每个可重集仅包含三种元素 $a_i,b_i,c_i$，且它们的个数分别为 $x,y,z$。对于每个 $t\in[0,2^k-1]$ 求<br>$$<br>\sum_{p_1\in S_1}\sum_{p_2\in S_2}\cdots\sum_{p_n\in S_n} [p_1\oplus p_2\oplus\cdots\oplus p_n=t]<br>$$<br>其中 $\oplus$ 表示按位异或。</p>
<p>$n\le 10^5,a_i,b_i,c_i&lt; 2^k,k\le 17$。</p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目即求二进制 $n$ 维循环卷积，直接暴力 FWT 是 $\mathcal{O}(nk2^k)$ 的，而注意到每个集合元素个数均相等，考虑从这方面入手分析。</p>
<p>下文用集合的形式表示二进制相关运算。</p>
<p>设 $m=2^k$，记 $\mathcal{F}:\mathbb{R}^m\to\mathbb{R}^m$ 为异或的沃尔什变换，$F[i]$ 表示 $F$ 在 $i$ 处的点值。</p>
<p>设答案的形式幂级数为 $G$，$n$ 个集合的形式幂级数为 $F_i$，则根据上文的暴力有<br>$$<br>\mathcal{F}(G)[k]=\prod_{i=1}^n\mathcal{F}(F_i)[k]<br>$$<br>对于特定的 $i$，讨论 $\mathcal{F}(F)[k]$，展开得到<br>$$<br>\mathcal{F}(F)[k]=\sum_{i=0}^{m-1}(-1)^{|i\cap k|}F[i]<br>$$<br>而 $F$ 仅在 $a,b,c$ 处取到非零值，带入有<br>$$<br>\mathcal{F}(F)[k]=(-1)^{|a\cap k|}x+(-1)^{|b\cap k|}y+(-1)^{|c\cap k|}z<br>$$<br>带入到原式得到<br>$$<br>\mathcal{F}(G)[k]=\prod_{i=1}^n(-1)^{|a_i\cap k|}x+(-1)^{|b_i\cap k|}y+(-1)^{|c_i\cap k|}z<br>$$<br>注意到右边即为 $8$ 个不同式子相乘，这里有一个小 trick 是先将所有 $a_i,b_i,c_i$ 异或上 $a_i$，最后算答案时还原回来，则原式转化成<br>$$<br>\mathcal{F}(G)[k]=\prod_{i=1}^nx+(-1)^{|b_i\cap k|}y+(-1)^{|c_i\cap k|}z<br>$$<br>这样变成了 $4$ 个不同的式子相乘，设 $s_1=x+y+z,$ $s_2=x+y-z,$ $s_3=x-y+z,$ $s_4=x-y-z$，则<br>$$<br>\mathcal{F}(G)[k]=\prod_{i=1}^4s_i^{p_i}<br>$$<br>问题转化为对任意 $k$ 求 $p_i$，则我们至少需要 $4$ 个方程，首先方案总和为 $n$，即<br>$$<br>\begin{align}<br>p_1+p_2+p_3+p_4=n\\<br>\end{align}<br>$$<br>不妨单独考虑 $y,z$ 前的系数，可以分 $3$ 种情况。</p>
<ol>
<li>只考虑 $y$ 前的系数，即 $$\sum_{i=1}^n(-1)^{|b_i\cap k|}=\sum_{i=0}^{m-1}(-1)^{|i\cap k|}\sum_{j=1}^n[b_j=i]$$<br>考虑构造 $H_1\in \mathbb{R}^m$，其中只有 $b_i$ 会对 $H_1$ 产生贡献，则 $$\sum_{i=0}^{m-1}(-1)^{|i\cap k|}\sum_{j=1}^n[b_j=i]=\sum_{i=0}^{m-1}(-1)^{|i\cap k|}H[i]=\mathcal{F}(H_1)[k]$$<br>同时显而易见的是，当 $s_i$ 中的 $y$ 取到正号时，$p_i$ 对系数有正的贡献，负号反之，即 $$\begin{align}p_1+p_2-p_3-p_4=\mathcal{F}(H_1)[k]\end{align}$$</li>
<li>只考虑 $z$ 前的系数，同理构造 $H_2\in\mathbb{R}^m$，其中只有 $c_i$ 会对 $H_2$ 产生贡献，得到 $$\begin{align}p_1-p_2+p_3-p_4=\mathcal{F}(H_2)[k]\end{align}$$</li>
<li>同时考虑 $y,z$ 前的系数，即 $$\begin{aligned}\sum_{i=1}^n(-1)^{|b_i\cap k|}(-1)^{|c_1\cap k|}&amp;=\sum_{i=0}^m(-1)^{|i\cap k|}H_1[i](- 1)^{|i\cap k|}H_2[i]\\&amp;=\mathcal{F}(H_1)[k]\cdot\mathcal{F}(H_2)[k]\end{aligned}$$<br>自然地构造出 $H_3\in\mathbb{R}^m$，只有 $b_i\oplus c_i$ 会对 $H_3$ 产生贡献，则 $$\sum_{i=1}^n(-1)^{|b_i\cap k|}(-1)^{|c_1\cap k|}=\mathcal{F}(H_1)[k]\cdot\mathcal{F}(H_2)[k]=\mathcal{F}(H_3)[k]$$<br>不难发现，当 $s_i$ 中的 $y,z$ 同号时，对系数有正的贡献，异号反之，则列得最后一个方程 $$\begin{align}p_1-p_2-p_3+p_4=\mathcal{F}(H_3)[k]\end{align}$$</li>
</ol>
<p>联立 $(1)\ (2)\ (3)\ (4)$ 式解得<br>$$<br>\begin{cases}<br>p_1=(\mathcal{F}(H_1)[k]+\mathcal{F}(H_2)[k]+\mathcal{F}(H_3)[k]+n)/4\\<br>p_i=(\mathcal{F}(H_{i-1})[k]-2p_1)/2&amp;\forall{i\in[2,4]}<br>\end{cases}<br>$$<br>时间复杂度 $\mathcal{O}((\log n+k)2^k)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, k, x, y, z, res = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">f1</span><span class="params">(<span class="number">1</span> &lt;&lt; k)</span>, <span class="title">f2</span><span class="params">(<span class="number">1</span> &lt;&lt; k)</span>, <span class="title">f3</span><span class="params">(<span class="number">1</span> &lt;&lt; k)</span>, <span class="title">g</span> <span class="params">(<span class="number">1</span> &lt;&lt; k)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, a, b, c; i &lt; n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    res ^= a, b ^= a, c ^= a;</span><br><span class="line">    f1[b] += <span class="number">1</span>, f2[c] += <span class="number">1</span>, f3[b ^ c] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">FWT</span>(f1, <span class="literal">false</span>), <span class="built_in">FWT</span>(f2, <span class="literal">false</span>), <span class="built_in">FWT</span>(f3, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> s1 = <span class="built_in"><span class="keyword">int</span></span>(x) + y + z, s2 = <span class="built_in"><span class="keyword">int</span></span>(x) + y - z,</span><br><span class="line">    s3 = <span class="built_in"><span class="keyword">int</span></span>(x) - y + z, s4 = <span class="built_in"><span class="keyword">int</span></span>(x) - y - z;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; k); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = (f1[i] + f2[i] + f3[i] + n) / <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c2 = (f1[i] + n - <span class="number">2</span> * c1) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c3 = (f2[i] + n - <span class="number">2</span> * c1) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c4 = (f3[i] + n - <span class="number">2</span> * c1) / <span class="number">2</span>;</span><br><span class="line">    g[i] = s1.<span class="built_in">power</span>(c1) * s2.<span class="built_in">power</span>(c2)</span><br><span class="line">         * s3.<span class="built_in">power</span>(c3) * s4.<span class="built_in">power</span>(c4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">FWT</span>(g, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; k); ++i) std::cout &lt;&lt; g[i ^ res] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Codeforces Round 770</title>
    <url>/cf-770/</url>
    <content><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定字符串 $S$，一次操作为 $S\gets rev(S) + S$ 或 $S\gets S + rev(S)$，求 $k$ 次操作后可以得到的字符串种数。</p>
<span id="more"></span>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先，如果 $S$ 本身回文或 $k=0$，答案显然为 $1$。</p>
<p>其次考虑 $k=2$ 的情况。第一次操作得到了 $SS’$ 或 $S’S$，其反转分别为 $S’S$ 和 $SS’$，显然拼接后仅有两种情况。故其他情况答案均为 $2$。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定 ${a},x,y$，保证恰存在一个 $d=x$ 或 $d=x+3$，一定存在操作使得 $d$ 与 $y$ 相等。</p>
<p>操作定义为依次考虑 $a_i$，$d\gets d+a_i$ 或 $d\gets d\oplus a_i$。</p>
<p>求 $x$ 与 $x+3$ 哪一个能满足条件。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>非常诈骗。</p>
<p>注意到 $x$ 与 $x+3$ 奇偶性不同，且异或和求和对最终的奇偶性的贡献是一样的，对 $a$ 中奇数个数讨论即可。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定 $n,k$，求一个 $nk$ 的排列，使得区间 $[1,k],[k+1,2k],\dots,[k(n-1), kn]$ 是好的。</p>
<p>定义一个区间是好的，当且仅当其区间内的所有区间的平均数均为整数。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>对于一个区间 $[qk, (q+1)k]$，其中的所有数奇偶性必定相同，并且一定存在一种构造方式，形如 ${2p+1,2p+3,\dots}$ 或 ${2p, 2p+2,\dots}$。</p>
<p>则有解当且仅当 $nk$ 中奇数与偶数的个数均可整除 $k$。直接按上述方式构造即可。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>猜一个序列 $a$ 中 $0$ 的下标，其中只包含一个 $0$，允许猜 $2$ 次。一次询问可以给出 $3$ 个互不相同的 $i,j,k$，返回 $\max(a_i,a_j,a_k)-\min(a_i,a_j,a_k)$。允许最多查询 $2n-2$ 次。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>考虑 $n=4$ 的情况。钦定 $a_1&lt;a_2&lt;a_3&lt;a_4$，则我们可以查 $4$ 次，分别可以表示成</p>
<ul>
<li>$(1,2,3)\to a_3-a_1$</li>
<li>$(1,2,4)\to a_4-a_1$</li>
<li>$(1,3,4)\to a_4-a_1$</li>
<li>$(2,3,4)\to a_4-a_2$</li>
</ul>
<p>不难发现，其中的最大值为 $a_4-a_1$ 且其一定出现了 $2$ 次，这两次查询中的没选的那个两个数一定不是答案，即得到 $2$ 个可能的答案。</p>
<p>对于 $n&gt;4$ 的情况，只要不断删去两个数即可，需要操作 $(n-2)/2\times 4=2n-4$ 次。</p>
<p>特别的，可能出现 $n=3$ 的情况，再任意补上一个数即可。</p>
]]></content>
  </entry>
  <entry>
    <title>Codeforces Educational Round 123</title>
    <url>/cf-edu-123/</url>
    <content><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定包含 $\texttt{RGBrgb}$ 各一次的字符串，判断 $\texttt{r,g,b}$ 是否分别在 $\texttt{R,G,B}$ 之前。</p>
<span id="more"></span>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>模拟即可。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>构造出 $n$ 个长度为 $n$ 的排列 $p$，使得不存在 $p_i=p_{i-1}+p_{i-2}$。</p>
<p>$1\le n\le 50$。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>做法很多，发现极大多数的排列均满足这一性质，可以直接随机或者爆搜解决。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定长度为 $n$ 的数组 $a$ 及整数 $x$，$\forall k\in[0,n]$，求<br>$$<br>\max_{1\le l\le r\le n}\left\{x\min\{k,(r-l+1)\}+\sum_{i=l}^ra_i\right\}<br>$$</p>
<p>$1\le n\le 5\times 10^3$。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>发现这个式子只与区间和和区间长度有关，考虑设 $f(i)$ 表示长度为 $i$ 的区间中区间和的最大值，答案即为<br>$$<br>\max_{1\le i\le n}\{f(i)+x\min\{k,(r-l+1)\}\}<br>$$</p>
<p>时间复杂度 $\mathcal{O}(n^2)$。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一个 $n$ 行 $m$ 列的网格及 $k$ 种颜色，有 $k$ 次涂色操作，每次操作都在 $(x,y)$ 所在行和所在列的所有元素涂上 $k$ 种颜色的一种，    求会产生多少种涂色方案。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>自然地想到倒序处理。</p>
<p>倒序处理后就不会出现覆盖的情况，可以记录下哪些行哪些列被标记，就可以判断当前点是否能产生贡献。</p>
<p>由于一次操作如果能产生贡献，则必然产生 $k$ 的贡献，故答案为 $k^{\text{cnt}}$，其中 $\text{cnt}$ 表示产生贡献的点的数量。</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>有一个 $n$ 行 $n$ 列的网格，及一个字符串 $S$，可以任意次对字符串中的元素进行复制，小 A 将从 $(1,1)$ 开始，依次执行串中的操作。操作存在两种，向右或向下行走。</p>
<p>问小 A 一共能达到点的个数。</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>做法一堆 <del>（甚至有线段树我不知道怎么想的）</del></p>
<p>先将相同的操作合并，考虑线性递推，记录每次操作的最靠近左上方的坐标和当前操作重复了多少次，由于不允许出到边界，考虑记下操作的后缀和，可以处理出当前操作可以到达的最大坐标，与当前坐标相减后乘上上一次的值即可计算当前的贡献。注意要减去重复的贡献即可。</p>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>定义 $F(a,k)$ 表示将数组 $a$ 的每个元素复制 $k$ 遍取前 $|a|$ 个得到的结果，$G(a,x,y)$ 表示将数组 $a$ 中所有为 $x$ 的元素变为 $y$，$y$ 变为 $x$ 所得到的数组。</p>
<p>定义 $a$ 是 $b$ 的祖先当且仅当存在一系列 $x$ 或 $x,y$ 使得不断对 $a$ 进行操作能得到 $b$。</p>
<p>给定 $n$，$k$，求最小的数列数量，满足对于所有的长度为 $n$、值域为 $[1,k]$ 的序列，存在一个序列使得成为祖先。</p>
<p>$1\le n,k\le 2\times 10^5$。</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>考虑没有 $F$ 的限制怎么做。</p>
<p>由于 $G$ 是一个双射，我们可以考虑枚举有 $i$ 个数相同，则相当于将序列分成了 $i$ 个子集，即方案数为<br>$$<br>\sum_{i=1}^{\min\{n,k\}}\begin{Bmatrix}n\\i\end{Bmatrix}<br>$$<br>这里 $n$ 比较大，无法 $\mathcal{O}(n^2)$ 求得第二类斯特林数，考虑斯特林数恒等式<br>$$<br>m!\begin{Bmatrix}n\\m\end{Bmatrix}=\sum_{i=0}^{m}(-1)^{m}\binom{m}{i}(m-i)^n<br>$$</p>
<p>整理可得到卷积的形式，即<br>$$<br>\begin{Bmatrix}n\\m\end{Bmatrix}=\sum_{i=0}^m\frac{(-1)^i}{i!}\times \frac{(m-i)^n}{(m-i)!}<br>$$</p>
<p>至此可以用 FFT 在 $\mathcal{O}(n\log n)$ 的时间内求得答案。</p>
<p>考虑加上 $F$ 的限制。</p>
<p>显然易见的是，$F(a,k)$ 的结果由 $\left\lfloor\dfrac nk\right\rfloor$ 个连续的长度为 $k$ 的子段及末尾不完整的子段构成（这些子段中的数均相等）。由于会有两个相同的子段，则如果除最后一段外，其长度的 $\gcd$ 不为 $1$，才可以由 $F$ 所表示出来。故答案即为<br>$$<br>\sum_{i=1}^n\mu(i)\sum_{j=1}^{\min{\left\lceil\frac{n}{i}\right\rceil,k}}\begin{Bmatrix}\left\lceil\frac{n}{i}\right\rceil\\j\end{Bmatrix}<br>$$</p>
<p>时间复杂度 $\mathcal O(n\log n)$，常数较大。</p>
]]></content>
  </entry>
  <entry>
    <title>斜率优化</title>
    <url>/convex_hull/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在动态规划的转移时，我们时常遇到形如 $f(i)=\min\limits_{j &lt; i}{f(j)}+w$ 的转移，这种转移可以用单调队列维护以做到线性的复杂度。斜率优化同样也是通过不断删去不合法和不优决策来优化 DP。</p>
<span id="more"></span>

<h2 id="例题引入"><a href="#例题引入" class="headerlink" title="例题引入"></a>例题引入</h2><h3 id="HNOI2008-玩具装箱-LG3195"><a href="#HNOI2008-玩具装箱-LG3195" class="headerlink" title="HNOI2008 玩具装箱 LG3195"></a>HNOI2008 玩具装箱 <a href="https://www.luogu.com.cn/problem/P3195">LG3195</a></h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>有 $n$ 个玩具，价值为 $c_i$ ，要求将这些玩具分段，每段的价值为 $(r-l+\sum\limits_{i=l}^rc_i-L)^2$ 。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>不难列出下列状态转移方程<br>$$<br>f(i)=\min_{1\le j&lt; i}{f(j)+(i-(j+1)+\sum_{k=j+1}^ic_k-L)^2}<br>$$<br>和式可以用前缀和 $sum$ 求得，设 $L’=L+1$ ，化简可得<br>$$<br>f(i)=\min_{1\le j&lt; i}{f(j)+(i-j+sum(i)-sum(j)-L’)^2}<br>$$<br>设 $s_i=sum_i+i$ ，可得<br>$$<br>f(i)=\min_{1\le j&lt; i}{f(j)+(s(i)-s(j)-L’)^2}<br>$$<br>这样做朴素转移是 $O(n^2)$ 的，考虑优化。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>以题目为例，展开得<br>$$<br>f(i)=\min_{1\le j&lt; i}{f(j)+s(i)^2+L^2+s(j)^2-2s(i)s(j)-2s(i)L’+2s(j)L’}<br>$$<br>将只与 $i$ 有关的项和常数项移到左边，得<br>$$<br>f(i)-s(i)^2-L^2+2s(i)L’=\min_{1\le j&lt; i}{f(j)+s(j)^2-2s(i)s(j)+2s(j)L’}<br>$$<br>至此，我们将这个问题转移到平面直角坐标系中，<strong>将一次转移看作一条线段，将未知量 $j$ 看作线段上的一个点</strong>，将式子转化得<br>$$<br>f(i)-s(i)^2-L^2+2s(i)L’=\min_{1\le j&lt; i}{f(j)+s(j)^2-2(s(i)-L’)s(j)}<br>$$<br>考虑直线的表达式 $y=kx+b$ ，转化得 $b=y-kx$ ，带入到上式中可得<br>$$<br>\begin{cases}<br>x=s(j)\\<br>y=f(j)+s(j)^2\\<br>k=2(s(i)-L’)\\<br>b=f(i)-s(i)^2-L^2+2s(i)L’<br>\end{cases}<br>$$<br>原式转化为<br>$$<br>b=\min{y-kx}<br>$$<br>也就是说，我们想要最小化一条斜率已知的直线的<strong>截距</strong>。</p>
<p>于是我们可以将这条直线不断向上平移，直到经过决策点集的其中一个点。如下图所示</p>
<p><img src="/images/Convex_1.svg"></p>
<p>考虑这些点有哪些性质。</p>
<p>发现对于任三个横坐标递增的点，会存在 $2$ 种情况，如图所示</p>
<p><img src="/images/Convex_2.svg"></p>
<p>我们把形似左图斜率不断增大的点集称为<strong>下凸包</strong>，右图斜率不断减小的点集称为<strong>上凸包</strong>，我们发现，右图的中间点不可能作为最优决策，左图的中间点有可能作为最优决策。所以这道题的决策点集在一个下凸包上。</p>
<p>不难发现，如果下凸包存在一个点 $j$ ，$ j$ 左侧的斜率 $&lt;$ 当前 $i$ 的斜率 $&lt;$$j$ 右侧的斜率，则 $j$ 为 $i$ 的最优决策点。</p>
<p>形象化的说，若当前的下凸包集合为 $S$ ，则最优决策点的下标 $p$ 应满足<br>$$<br>\text{slove}(S_{p-1},S_p) &lt; k_i &lt; \text{slove}(S_p, S_{p+1})<br>$$<br>其中 $\text{slove}$ 表示两点之间的斜率。</p>
<p>由于 $k,x$ 是单调递增的，所以我们可以通过一些方式，及时删掉决策中不优的点，以保证时间复杂度。</p>
<p>考虑用单调队列 $q$ 优化，$l$ 表示队头， $r$ 表示队尾，实现方式如下：</p>
<ol>
<li>队列中先保存 $0$ 这个点，以构成一条线段；</li>
<li>将 $\text{slove}(q_l,q_{l+1}) &lt; k_i$ 的队头弹出，保证决策最优；</li>
<li>用队头更新答案；</li>
<li>将 $\text{slove}(q_{r-1},q_r) &gt; \text{slove}(q_r,i)$ 的队尾弹出，以维护下凸包；</li>
<li>将 $i$ 压入队尾。</li>
</ol>
<p>由于每个点至多入队出队一次，时间复杂度均摊 $O(1)$ ，总时间复杂度 $O(n)$ 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) (x) * (x)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, L, q[MAXN], l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (f[y] + <span class="built_in">sqr</span>(s[y]) - f[x] - <span class="built_in">sqr</span>(s[x])) / (s[y] - s[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, L); L++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) <span class="built_in">read</span>(x), s[i] = s[i - <span class="number">1</span>] + x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">slope</span>(q[l], q[l + <span class="number">1</span>]) &lt; <span class="number">2.0</span> * (s[i] - L)) ++l;</span><br><span class="line">        f[i] = f[q[l]] + <span class="built_in">sqr</span>(s[i] - s[q[l]] - L);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">slope</span>(q[r - <span class="number">1</span>], q[r]) &gt; <span class="built_in">slope</span>(q[r], i)) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这个算法应用各元素的比值，从而快速维护 DP 的转移。由于比值类似坐标系中的斜率，我们将这种 DP 优化方式称为<strong>斜率优化</strong>。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="JSOI2011-柠檬-LG5504"><a href="#JSOI2011-柠檬-LG5504" class="headerlink" title="JSOI2011 柠檬 LG5504"></a>JSOI2011 柠檬 <a href="https://www.luogu.com.cn/problem/P5504">LG5504</a></h3><h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>有 $n$ 个大小为 $s_i$ 的贝壳，你可以选择一些不交的区间 $[l,r]$ ，对于每个区间，你可以选择一个大小 $s_0$ ，你可以获得 $s_0T^2$ 个柠檬，$ T$ 是 $[l,r]$ 中大小为 $s_0$ 的贝壳的个数。求最多能获得的柠檬数。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>不难发现，在最优策略中，对于每一个区间 $<a href="l%3Cr">l,r</a>$ ，必定满足 $s_l=s_r$ ，不然一定比分开选不优。</p>
<p>设 $[1,i]$ 中有 $c_i$ 个大小为 $s_i$ 的贝壳，$ f(i)$ 为 最大获得的柠檬数，可以列出状态转移方程<br>$$<br>f(i)=\max_{1\le j &lt; i,s_i=s_j}{f(j-1)+s_i(c_i-c_j+1)^2}<br>$$<br>同样考虑斜率优化，先化简可得<br>$$<br>f(i)=\max_{1\le j &lt; i,s_i=s_j}{f(j-1)+s_i+2s_ic_i+s_ic_i^2-2s_ic_j-2s_ic_ic_j+s_ic_j^2}<br>$$<br>注意到 $s_i=s_j$ ，可得<br>$$<br>f(i)-s_i-2s_ic_i-s_ic_i^2=\max_{1\le j &lt; i,s_i=s_j}{f(j-1)-2s_jc_j+s_jc_j^2-2s_ic_ic_j}<br>$$<br>此时<br>$$<br>\begin{cases}<br>x=c_j\\<br>y=f(j-1)-2s_jc_j+s_jc_j^2\\<br>k=2s_ic_i\\<br>b=f(i)-s_i-2s_ic_i-s_ic_i^2<br>\end{cases}<br>$$<br>由于这里要维护 $\max$ ，就相当于维护一个上凸包。由于上凸包的斜率是单调递减的，故最优决策点要满足 $\text{slove}(S_p,S_{p+1}) &lt; k_i &lt; \text{slove}(S_{p-1}, S_p)$ ，故将所有满足 $\text{slove}(S_{p-1}, S_p)&lt;k_i$ 的 $p$ 弹出集合，同时 $k$ 是单调递增的，此时集合内的斜率均 $&gt; k_i$ ，取出直接转移即可。发现所有操作均在队尾执行，直接用单调栈维护即可。</p>
<h2 id="二分维护整个凸包"><a href="#二分维护整个凸包" class="headerlink" title="二分维护整个凸包"></a>二分维护整个凸包</h2><h3 id="SDOI2012-任务安排-LG5785"><a href="#SDOI2012-任务安排-LG5785" class="headerlink" title="SDOI2012 任务安排 LG5785"></a>SDOI2012 任务安排 <a href="https://www.luogu.com.cn/problem/P5785">LG5785</a></h3><h4 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h4><p>有 $n$ 个任务，第 $i$ 个任务需要 $T_i$ 的时间完成，要求将 $n$ 个任务依次分为若干批，每批开始前需要 $s$ 的时间，完成这批任务的时间为所有任务时间的总和（同一批任务结束时间相同），每个任务的价值为 $C_i$ 乘上该任务完成的时间，求一个最优方案，使总价值最小。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>考虑 DP，设 $f(i)$ 表示 $1\sim i$ 的最小总价值。对于新增的一段 $[j+1,i]$ ，要对之后所有段产生贡献，对当前段也产生了贡献，可列出状态转移方程为<br>$$<br>f(i)=\min_{1\le j &lt; i}{f(j)+S\sum_{k=j+1}^nC_k+\sum_{k=1}^iT_k\times\sum_{k=j+1}^iC_k}<br>$$<br>用前缀和代替和式可得<br>$$<br>f(i)=\min_{1\le j &lt; i}{f(j)+S(sumC_n-sumC_j)+sumT_i(sumC_i-sumC_j)}<br>$$<br>这样转移是 $O(n^2)$ ，考虑转化成斜率优化的形式，即<br>$$<br>f(i)-SsumC_n-sumT_isumC_i=\min_{1\le j &lt; i}{f(j)-(S+sumT_i)sumC_j)}<br>$$<br>此时<br>$$<br>\begin{cases}<br>x=sumC_j\\<br>y=f(j)\\<br>k=S+sumT_i\\<br>b=f(i)-SsumC_n-sumT_isumC_i<br>\end{cases}<br>$$</p>
<p>若 $T_i&gt;0$ ，可以直接套板子解决，而这题中 $T_i$ 可以为负数，说明 $k$ 不是单调递增的，则我们不能通过弹出队头来保证答案最优，并且队头也不一定是最优决策点。</p>
<p>考虑维护整个凸包，由于下凸包中的斜率是单调递增的，所以可以在凸包中二分找到满足 $\text{slove}(S_{p-1},S_p) &lt; k_i &lt; \text{slove}(S_p, S_{p+1})$ 的点，然后常规从队尾入队即可。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, s, dp[MAXN], f[MAXN], t[MAXN], q[MAXN], l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = l, R = r;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((dp[q[mid + <span class="number">1</span>]] - dp[q[mid]]) &lt;= k * (f[q[mid + <span class="number">1</span>]] - f[q[mid]])) L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">read</span>(x, y);</span><br><span class="line">        t[i] = t[i - <span class="number">1</span>] + x; f[i] = f[i - <span class="number">1</span>] + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">binary_search</span>(t[i] + s);</span><br><span class="line">        dp[i] = dp[p] + t[i] * (f[i] - f[p]) + s * (f[n] - f[p]);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; (dp[q[r]] - dp[q[r - <span class="number">1</span>]]) * (f[i] - f[q[r]]) &gt;= (dp[i] - dp[q[r]]) * (f[q[r]] - f[q[r - <span class="number">1</span>]])) r--;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在上述例题中，题目均保证了横坐标 $x_i$ 单调，然而在一些毒瘤题中，题目并不保证 $x_i$ 或 $k_i$ 单调，此时需要通过一些奇妙的数据结构维护整个凸包。</p>
<h3 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="CDQ 分治"></a>CDQ 分治</h3><p>CDQ 分治，即基于时间的分治算法，其基本思想为</p>
<ul>
<li>对于区间 $[l,r]$，递归分治 $[l,mid]$ 与 $[mid+1,r]$。</li>
<li>计算左半区间的修改对右半区间的影响。</li>
</ul>
<p>借助 CDQ 分治，我们可以先处理左半区间，维护左半部分的凸包，更新右半部分的答案，再处理右半区间，最后以 $x_i$ 为关键字归并排序。</p>
<p>至此，维护凸包时我们保证了 $x_i$ 单调，我们就可以用队列/栈维护凸包，同时保证了时间复杂度的正确性。</p>
<p>对于时间复杂度，有递推式<br>$$<br>T(n)=2T\left(\frac{n}{2}\right)+O(n)<br>$$<br>根据主定理，可得最终时间复杂度为 $\Theta(n\log n)$。</p>
<h4 id="SDOI2012-基站建设"><a href="#SDOI2012-基站建设" class="headerlink" title="SDOI2012 基站建设"></a><a href="https://www.luogu.com.cn/problem/P2497">SDOI2012 基站建设</a></h4><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>根据勾股定理<br>$$<br>(r_{1,i}+r_{2_j})^2=(r_{2,i} - r_{1,j})^2+(x_i-x_j)^2\to \sqrt{r_{2,i}}=\frac{x_i-x_j}{2\sqrt{r_{1,j}}}<br>$$<br>可列出状态转移方程<br>$$<br>f_i=\min_{j&lt;i}{f_j+\frac{x_i-x_j}{2\sqrt{r_{1,j}}}}+v_i<br>$$<br>此时有<br>$$<br>\begin{cases}<br>x=\dfrac{1}{2\sqrt{r_{1,j}}}\\<br>y=f_j-\dfrac{x_j}{2\sqrt{r_{1,j}}}\\<br>k=-x_i\\<br>b=f_i-v_i<br>\end{cases}<br>$$<br>此时 $x$ 不单调，可以用 CDQ 分治维护。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q[MAXN], _r[MAXN], v[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> C, x[MAXN];</span><br><span class="line"><span class="keyword">double</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125; Q[MAXN], tmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (Q[i].y - Q[j].y) / (Q[i].x - Q[j].x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(Q[l].y = f[Q[l].id] - Q[l].x * x[Q[l].id]);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve</span>(l, mid);</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">slope</span>(q[R - <span class="number">1</span>], q[R]) &gt; <span class="built_in">slope</span>(q[R], i)) R--;</span><br><span class="line">        q[++R] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">slope</span>(q[R - <span class="number">1</span>], q[R]) &gt; <span class="number">-1.0</span> * x[Q[i].id]) R--;</span><br><span class="line">        f[Q[i].id] = std::<span class="built_in">min</span>(f[Q[i].id], f[Q[q[R]].id] + Q[q[R]].x * (x[Q[i].id] - x[Q[q[R]].id]) + v[Q[i].id]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, p1 = l, p2 = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p2 &gt; r || (p1 &lt;= mid &amp;&amp; Q[p1].x &lt; Q[p2].x)) tmp[i] = Q[p1++];</span><br><span class="line">        <span class="keyword">else</span> tmp[i] = Q[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) Q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io &gt;&gt; n &gt;&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        io &gt;&gt; x[i] &gt;&gt; _r[i] &gt;&gt; v[i];</span><br><span class="line">        Q[i] = &#123;<span class="number">0.5</span> / <span class="built_in">sqrt</span>(_r[i]), <span class="number">0</span>, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = <span class="number">2e18</span>;</span><br><span class="line">    f[<span class="number">1</span>] = v[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">2e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (x[i] + _r[i] &gt;= C) ans = std::<span class="built_in">min</span>(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h3><p>李超线段树，即标记持久化的线段树，可以在线维护类似下列的问题</p>
<ul>
<li>在平面中插入一条线段。</li>
<li>求一个区间内所有线段纵坐标的最小值。</li>
<li>对于横坐标 $x$，求所有线段中纵坐标的最小值。</li>
</ul>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>对于区间 $[l,r]$，定义这个区间的最优线段为</p>
<ul>
<li>定义域包括 $[l,r]$。</li>
<li>在 $x=mid$ 时纵坐标最小。</li>
</ul>
<p>在我们在 $[l,r]$ 上插入一条线段 $v$，将其与原最优线段 $u$ 比较，如图所示，分 $4$ 种情况。<br><img src="/images/Lichao.svg"></p>
<p>设 $x=mid$ 时两条线段的取值分别为 $res_v$ 与 $res_u$，则有</p>
<ul>
<li><p>$k_u&lt;k_v\land res_u&gt;res_v$</p>
<p>如图所示，此时最优线段为 $v$，同时用 $u$ 更新左半区间（右半区间必定为 $v$）</p>
</li>
<li><p>$k_u&lt;k_v\land res_u&lt;res_v$</p>
<p>如图所示，此时最优线段为 $u$，同时用 $v$ 更新右半区间（左半区间必定为 $u$）</p>
</li>
<li><p>$k_u&gt;k_v\land res_u&gt;res_v$</p>
<p>如图所示，此时最优线段为 $v$，同时用 $u$ 更新右半区间（左半区间必定为 $v$）</p>
</li>
<li><p>$k_u&gt;k_v\land res_u&lt;res_v$</p>
<p>如图所示，此时最优线段为 $u$，同时用 $v$ 更新左半区间（右半区间必定为 $u$）</p>
</li>
</ul>
<p>此外对于 $k_u=k_v$，只需比较 $u$ 与 $v$ 的截距即可。</p>
<p>在查询时，不断更新当前区间最优值，并向下递归即可。</p>
<p>关于时间复杂度，由于一个区间会被分成 $O(\log n)$ 个区间，每个区间需要 $\Theta(\log n)$ 修改，所以总时间时间复杂度为 $O(n\log^2 n)$。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LG 4097</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> k, b;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">Line</span>(): <span class="built_in">k</span>(<span class="number">0</span>), <span class="built_in">b</span>(<span class="number">0</span>), <span class="built_in">id</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> _id) &#123;</span><br><span class="line">        id = _id;</span><br><span class="line">        <span class="keyword">if</span> (x1 == x2) &#123;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">            b = std::<span class="built_in">max</span>(y1, y2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = <span class="number">1.0</span> * (y1 - y2) / (x1 - x2);</span><br><span class="line">            b = y1 - k * x1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k * x + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; <span class="title">pmax</span><span class="params">(std::pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; a, std::pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.first &gt; b.first) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.first &lt; b.first) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Li_Chao_Segment_Tree</span> &#123;</span></span><br><span class="line">    Line s[<span class="number">160010</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (x &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, Line v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; R || r &lt; L) <span class="keyword">return</span>;</span><br><span class="line">        Line u = s[x];</span><br><span class="line">        <span class="keyword">double</span> resu = u.<span class="built_in">calc</span>(mid), resv = v.<span class="built_in">calc</span>(mid);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resv &gt; resu) s[x] = v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u.k &lt; v.k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resv &gt; resu) &#123;</span><br><span class="line">                    s[x] = v;</span><br><span class="line">                    <span class="built_in">insert</span>(lson, l, mid, L, R, u);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="built_in">insert</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.k &gt; v.k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resv &gt; resu) &#123;</span><br><span class="line">                    s[x] = v;</span><br><span class="line">                    <span class="built_in">insert</span>(rson, mid + <span class="number">1</span>, r, L, R, u);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="built_in">insert</span>(lson, l, mid, L, R, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v.b &gt; u.b) s[x] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">insert</span>(lson, l, mid, L, R, v);</span><br><span class="line">        <span class="built_in">insert</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u &lt; l || u &gt; r) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> res = s[x].<span class="built_in">calc</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> &#123;res, s[x].id&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pmax</span>(&#123;res, s[x].id&#125;, <span class="built_in">pmax</span>(<span class="built_in">query</span>(lson, l, mid, u), <span class="built_in">query</span>(rson, mid + <span class="number">1</span>, r, u)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> op, x1, x2, y1, y2, cnt = <span class="number">0</span>; Q--;) &#123;</span><br><span class="line">        io &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;</span><br><span class="line">            io &gt;&gt; x1;</span><br><span class="line">            x1 = (x1 + ans - <span class="number">1</span>) % P1 + <span class="number">1</span>;</span><br><span class="line">            io &lt;&lt; (ans = st.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, P1, x1).second) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            io &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            x1 = (x1 + ans - <span class="number">1</span>) % P1 + <span class="number">1</span>;</span><br><span class="line">            x2 = (x2 + ans - <span class="number">1</span>) % P1 + <span class="number">1</span>;</span><br><span class="line">            y1 = (y1 + ans - <span class="number">1</span>) % P2 + <span class="number">1</span>;</span><br><span class="line">            y2 = (y2 + ans - <span class="number">1</span>) % P2 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x1 &gt; x2) std::<span class="built_in">swap</span>(x1, x2), std::<span class="built_in">swap</span>(y1, y2);</span><br><span class="line">            st.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">1</span>, P1, x1, x2, <span class="built_in">Line</span>(x1, y1, x2, y2, ++cnt));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如何用李超线段树来维护凸包，其优点在于何处，下面给出一道例题。</p>
<h4 id="CF932F-Escape-Through-Leaf"><a href="#CF932F-Escape-Through-Leaf" class="headerlink" title="CF932F Escape Through Leaf"></a><a href="https://codeforces.com/contest/932/problem/F">CF932F Escape Through Leaf</a></h4><h5 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h5><p>给定一棵树，根为 $1$，每次操作可以从 $u$ 走到 $v$，获得的价值为 $a_v\times b_u$，且满足 $u$ 在 $v$ 的子树内，求对于每一个终点的最小总代价。</p>
<p>$n,|a_i|,|b_i|\le 10^5$</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>首先有一个很显然的 $O(n^2)$ DP，即<br>$$<br>f(u)=\min{f(v)+a_ub_v}\qquad v \in subtree(u)<br>$$</p>
<p>显然可以斜率优化，但与常规方法不同的是，我们钦定使纵坐标最小，则有<br>$$<br>\begin{cases}<br>x=a_u\\<br>y=f(u)\\<br>k=b_v\\<br>b=f(v)<br>\end{cases}<br>$$<br>这要求我们在每次转移时要插入一条斜率为 $b_v$，截距为 $f(v)$ 的直线，且回溯时将 $v$ 上的线段树合并到 $u$ 上，可以用动态开点李超线段树合并实现。</p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k, b;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x * k + b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> rt[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LICHAO_SEGMENT_TREE</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    Line s[MAXN &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> ls[MAXN &lt;&lt; <span class="number">5</span>], rs[MAXN &lt;&lt; <span class="number">5</span>], tol;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, Line v, <span class="keyword">int</span> l = <span class="number">-1e5</span>, <span class="keyword">int</span> r = <span class="number">1e5</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">            x = ++tol;</span><br><span class="line">            s[x] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Line u = s[x];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> resu = u.<span class="built_in">calc</span>(mid), resv = v.<span class="built_in">calc</span>(mid);</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resu &gt; resv) s[x] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u.k &lt; v.k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resv &lt; resu) &#123;</span><br><span class="line">                s[x] = v;</span><br><span class="line">                <span class="built_in">insert</span>(rs[x], u, mid + <span class="number">1</span>, r);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">insert</span>(ls[x], v, l, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.k &gt; v.k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resv &lt; resu) &#123;</span><br><span class="line">                s[x] = v;</span><br><span class="line">                <span class="built_in">insert</span>(ls[x], u, l, mid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">insert</span>(rs[x], v, mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.b &gt; v.b) s[x] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l = <span class="number">-1e5</span>, <span class="keyword">int</span> r = <span class="number">1e5</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x ^ y;</span><br><span class="line">        <span class="built_in">insert</span>(x, s[y], l, r);</span><br><span class="line">        ls[x] = <span class="built_in">merge</span>(ls[x], ls[y], l, mid);</span><br><span class="line">        rs[x] = <span class="built_in">merge</span>(rs[x], rs[y], mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p, <span class="keyword">int</span> l = <span class="number">-1e5</span>, <span class="keyword">int</span> r = <span class="number">1e5</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">return</span> INT64_MAX;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">min</span>(s[x].<span class="built_in">calc</span>(p),</span><br><span class="line">        p &lt;= mid ? <span class="built_in">query</span>(ls[x], p, l, mid) : <span class="built_in">query</span>(rs[x], p, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; st;</span><br><span class="line"><span class="keyword">int</span> n, head[MAXN], nxt[MAXN &lt;&lt; <span class="number">1</span>], ver[MAXN &lt;&lt; <span class="number">1</span>], a[MAXN], b[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    nxt[++head[<span class="number">0</span>]] = head[u];</span><br><span class="line">    ver[head[u] = head[<span class="number">0</span>]] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((v = ver[i]) == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        rt[u] = st.<span class="built_in">merge</span>(rt[u], rt[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u] = st.<span class="built_in">query</span>(rt[u], a[u]);</span><br><span class="line">    <span class="keyword">if</span> (f[u] == INT64_MAX) f[u] = <span class="number">0</span>;</span><br><span class="line">    st.<span class="built_in">insert</span>(rt[u], &#123;b[u], f[u]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) io &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) io &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++) &#123;</span><br><span class="line">        io &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) io &lt;&lt; f[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这道例题，可以发现李超线段树可以很好的处理树上的斜率优化 DP，并且不需要满足单调的性质，可拓展性好。</p>
<p>此外，还可以用平衡树维护凸包，但过程复杂且常数较大，这里不再赘述。</p>
<h2 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h2><h3 id="序列sequence"><a href="#序列sequence" class="headerlink" title="序列sequence"></a><a href="https://www.luogu.com.cn/problem/P4597">序列sequence</a></h3><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先有一个显然的 $O(n^2)$ 的 DP，即<br>$$<br>f(i,j)=\min_{k\le j}{f(i-1,k)}+|a_i-j|<br>$$<br>定义序列函数<br>$$<br>f_i(x)=\begin{cases}<br>0&amp;i=0\\<br>\min\limits_{p\le x}{f_{i-1}(p)}+|a_i-x|&amp;i&gt;0<br>\end{cases}<br>$$<br>则有</p>
<blockquote>
<p>$\forall i\in \mathbf{N}^*$，$f_i(x)$ 构成一个下凸包。</p>
</blockquote>
<h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>当 $i=1$ 时，$f_1(x)=|a_1-x|$ 为一个分段函数，在 $x=a_1$ 时取得最小值，此时必定构成一个下凸包。</p>
<p>当 $i&gt;1$ 时，假定 $f_{i-1}(x)$ 构一个下凸包，即证 $f_i(x)$ 构成一个凸包。</p>
<p>根据 $f(x)$ 的定义，$f_i(x)$ 由一系列一次函数构成，考虑当前一次函数的斜率 $k$ 与 $a_i$ 对一个转移过程中的影响。</p>
<ul>
<li><p>$k&lt;0,x\le a_i$</p>
<p>由于 $f_{i-1}(x)$ 是下凸的，所以当 $k&lt;0$ 时，$f_{i-1}(x)$ 单调递减。此时 $f_{i-1}(x)$ 的前缀最小值在 $x$ 处取到。则有<br>$$<br>f_i(x)=f_{i-1}(x)+a_i-x<br>$$<br>此时，将 $f_{i-1}(x)$ 转化为一次函数的形式，则这个区间上的转移相当于 $k\gets k-1$，即斜率递减 $1$。</p>
</li>
<li><p>$k&lt;0,x&gt; a_i$</p>
<p>同第一种情况，我们得到<br>$$<br>f_i(x)=f_{i-1}(x)-a_i+x<br>$$<br>同样这里相当于 $k\gets k+1$，即斜率递增 $1$。</p>
</li>
<li><p>$k\ge 0,x\le a_i$</p>
<p>当 $k\ge 0$ 时，$f_{i-1}(x)$ 单调不降。此时设 $f_{i-1}(x)$ 的最小值在 $op$ 处取到，设最小值为 $\gamma$。则有<br>$$<br>f_i(x)=\gamma+a_i-x<br>$$<br>对于某一个特定的 $f_{i-1}(x)$，$\gamma$ 唯一，故这里相当于 $k\gets -1$，即将斜率变为 $-1$。</p>
</li>
<li><p>$k\ge 0,x &gt; a_i$</p>
<p>同情况 3，可得<br>$$<br>f_i(x)=\gamma-a_i+x<br>$$</p>
<p>则 $k\gets 1$，即将斜率变为 $1$。</p>
</li>
</ul>
<p>现在考虑在 $f_{i-1}\to f_i$ 的转移中，可能会出现的情况，如图所示，存在 $2$ 种情况。</p>
<p>!GRAPH</p>
<ul>
<li><p>$a_i &lt; op$</p>
<p>如图所示，此时的转移会出现情况 1，2，4 这三种。</p>
<ul>
<li>对于 $x\in [1, op]$：$x\in[1, a_i]$ 时较小的斜率更小，$x\in (a_i, op]$ 时较大的斜率更大，且必定 $\le 0$。</li>
<li>对于 $x\in (op, +\infty)$：斜率恒定不变为 $1$，必定大于 $[1,op]$ 中所有斜率不大于 $0$。</li>
</ul>
</li>
<li><p>$a_i \ge op$</p>
<p>如图所示，此时的转移会出现情况 1，3，4 这三种。</p>
<ul>
<li>对于 $x\in [1, op]$：所有斜率递减 $1$，且必定 $&lt; -1$。</li>
<li>对于 $x\in (op, +\infty)$：$x\in(op, a_i]$ 时，斜率恒定不变为 $-1$，必定大于 $[1,op]$ 中所有斜率小于 $-1$。$x\in (a_i, +\infty)$ 时，斜率恒定不变为 $1$，同样满足条件。</li>
</ul>
</li>
</ul>
<p>综合以上两种情况，我们可以得出若 $f_{i-1}(x)$ 下凸，则 $f_i(x)$ 下凸。即原命题得证。$\square$</p>
<p>有这个性质之后我们发现，我们要求 $\min{f_n(x)}$，且对于 $f_{i-1}\to f_i$ 的转移中，斜率 $&gt;0$ 的区间对答案没有贡献，可以直接将这一段舍去，则函数的最小值在 $x$ 最大时取到。</p>
<p>考虑维护一个堆，存 $f_i(x)$ 的每一个拐点，考虑每次插入 $a_i$ 对答案的影响。</p>
<ul>
<li><p>$a_i\ge op$</p>
<p>此时决策点为 $a_i$，答案不变，将 $a_i$ 插入堆（$f_i(a_i)=f_{i-1}(op)+|a_i-a_i|$）。</p>
</li>
<li><p>$a_i&lt;op$</p>
<p>如图所示，此时由于新决策点 $op’$ 与 $op$ 之间的斜率为 $0$，可以弹出 $op$，直接更新答案（$f_i(op’)=f_i(op)=f_{i-1}(op)+|a_i-op|$）。</p>
<p>!GRAPH</p>
</li>
</ul>
<p>至此，我们可以用一个及其简洁的代码实现上列过程。</p>
]]></content>
  </entry>
  <entry>
    <title>从多项式乘法到快速傅里叶变换</title>
    <url>/covolution-to-fft-ntt/</url>
    <content><![CDATA[<h2 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h2><h3 id="点值表示法"><a href="#点值表示法" class="headerlink" title="点值表示法"></a>点值表示法</h3><p>在做多项式乘法时, 类似于竖式乘法, 一个朴素的想法是将一个多项式的每一项与另一个多项式的每一项相乘, 得到新的多项式, 时间复杂度 $\Theta(n^2)$。</p>
<p>我们考虑对多项式看作向量, 对其做线性变换, 其和系数表达是一一对应的, 从而可以在其变换上考虑。因此, 我们引入了点值表示。</p>
<span id="more"></span>
<p>初中我们就学过, 3 个点可以确定一个二次函数。将其扩展可以得到</p>
<blockquote>
<p>定理</p>
<p>$n+1$ 个点可以确定一个 $n$ 阶多项式。</p>
</blockquote>
<blockquote>
<p>反证法。</p>
<p>假设存在两个不相同的 $n$ 阶多项式 $f(x),g(x)$, 使得它们有 $n+1$ 个交点, 则对于 $n$ 次函数 $h(x)=f(x)-g(x)$ 在 $x$ 轴上有 $n+1$ 个交点, 而由 $n$ 次方程恰有 $n$ 个根, 这是不可能的。故假设不成立, 即原命题得证。</p>
</blockquote>
<p>因此, 我们可以用 $n+1$ 个点唯一表示一个多项式, 即<br>$$<br>f(x)=\{(x_0,y_0),(x_1,y_1),\dots,(x_n,y_n)\}<br>$$<br>我们将这种表示方法称作多项式的<strong>点值表示</strong>。</p>
<p>显然, 如果得出了两个多项式的点值表示法, 那么多项式的乘法将变的非常简单, 即将纵坐标相乘。至此, 问题转化成高效实现这个线性变换。我们将这种变换称为多项式的离散傅里叶变换。</p>
<p>但是, 我们确定了 $n+1$ 个点的横坐标时, 仍需要 $\Theta(n^2)$ 时间得到整个点集, 同时逆变换更是一个棘手的问题。因此, 我们引入了快速傅里叶变换。接下来介绍其中一种最常见的算法—库利—图基算法 (Cooley-Tukey)。</p>
<p>想要优化这个变换过程, 我们可以从减少选点的数量入手, 即期望选取更少的点, 同时这些点可以表达整个多项式。我们可以考虑, 选取了一个点 $(x,y)$ 后, 存在 $(-x, y)$ 或 $(-x, -y)$ 在这个多项式上, 那么选取的点的数量就可以减少了。</p>
<p>不难发现, 以上的性质对应于函数的奇偶性, 因此, 我们可以将这个多项式分解成奇偶两部分, 即<br>$$<br>f(x)=x\times g(x^2)+h(x^2)<br>$$</p>
<p>通过这种方式, 我们可以选取至多 $\dfrac{n}{2}$ 个点 $\{\pm x_0,\pm x_1,\dots,\pm x_{n/2-1}\}$, 并递归分治求解两个子问题, 向上合并时不难得到<br>$$<br>\forall i\in\left[0,\frac{n}{2}-1\right],<br>\begin{cases}<br>    f(x_i)=x\times g(x_i^2)+h(x_i^2)\\<br>    f(-x_i)=-x\times g(x_i^2)+h(x_i^2)<br>\end{cases}<br>$$<br>我们分析一下复杂度, 这个算法将问题分为了两个子问题, 并递归求解, 则有 $T(n)=2T\left(\dfrac n2\right)+\Theta(n)=\Theta(n\log n)$。至此, 这个算法可以在比较快的时间里解决多项式的离散傅里叶变换。</p>
<p>但是, 在分治过程中会存在一个问题, 即分治的子函数 $g,h$ 的横坐标均为正数, 不满足 $f$ 的横坐标互为相反数。而这就是 FFT 最精妙的思想—将这些数取成复数, 使得平方后仍然是互为相反数。</p>
<h3 id="单位复根"><a href="#单位复根" class="headerlink" title="单位复根"></a>单位复根</h3><p>在研究复数时, 我们通常与复平面结合起来研究问题。我们先来观察一个特例。</p>
<p>考虑 $n=4$, 先取横坐标为 1 的点, 则显然 $(-1)^2=1,1^2=1$, 再次向下递归时, 有 $i^2=-1,(-i)^2=-1$。不难发现, 这个过程相当于求解了一个方程 $x^n=1$。我们知道, 复数的乘法运算是“模长相乘, 辐角相加”, 则不难将其转移到单位圆上, 如图所示表示 $n=8$ 的情况。</p>
<p>There is a graph(TODO).</p>
<p>观察上图, 我们可以发现 $x^n=1$ 的解相当于将单位圆均分成 $n$ 份得到 $n$ 个点。</p>
<blockquote>
<p>定义</p>
<p>$\omega_n$ 表示单位圆上 $n$ 个点中最小的正角, 则 $\omega_n=\cos \left(\dfrac{2\pi}{n}\right)+i\sin\left(\dfrac{2\pi}{n}\right)$, 将 $\omega_n$ 称为<strong>单位复根</strong>。</p>
</blockquote>
<p>我们不难发现, $\forall k\in[0,n-1],\omega_n^k$ 相当于单位复根在单位圆上旋转, 其模长均为 1。</p>
<blockquote>
<p>定理</p>
<p>$\omega_n^k(k\in[0,n-1])$ 是 $x^n=1$的 $n$ 个根。</p>
</blockquote>
<blockquote>
<p>证明</p>
<p>根据欧拉公式 (Euler Format) , $\omega_n=\cos \left(\dfrac{2\pi}{n}\right)+i\sin\left(\dfrac{2\pi}{n}\right)=e^{\frac{2\pi i}{n}}$。</p>
<p>则 $\left(\omega_n^k\right)^n=\left(\left(e^{\frac{2\pi i}{n}}\right)^k\right)^n=\left(e^{2\pi i}\right)^k=\left((-1)^2\right)^k=1^k=1$</p>
</blockquote>
<p>再次观察上图我们发现, 两个根互为相反数, 则两个根在一条直线上, 即 $\omega_n^k=-\omega_n^{k+n/2}$, 分治过程中我们对一个根进行平方, 即 $\left(\omega_n^k\right)^2=\left(e^{\frac{4\pi i}{n}}\right)^k=\left(e^{\frac{2\pi i}{n/2}}\right)^k=\omega_{n/2}^k$。据此, 我们带入到上述递归式中, 得到<br>$$<br>\begin{aligned}<br>    f\left(\omega_n^k\right)&amp;=\omega_n^k\times g\left(\left(\omega_n^k\right)^2\right)+h\left(\left(\omega_n^k\right)^2\right)\\&amp;=\omega_n^k\times g\left(\omega_{n/2}^k\right)+h\left(\omega_{n/2}^k\right)<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>    f\left(\omega_n^{k+n/2}\right)&amp;=f\left(-\omega_n^k\right)\\&amp;=-\omega_n^k\times g\left(\left(\omega_n^k\right)^2\right)+h\left(\left(\omega_n^k\right)^2\right)\\&amp;=-\omega_n^k\times g\left(\omega_{n/2}^k\right)+h\left(\omega_{n/2}^k\right)<br>\end{aligned}<br>$$</p>
<p>至此, 我们通过引入复数, 成功解决了多项式的离散傅里叶变换。</p>
<h3 id="快速傅里叶逆变换"><a href="#快速傅里叶逆变换" class="headerlink" title="快速傅里叶逆变换"></a>快速傅里叶逆变换</h3><p>在多项式乘法中, 我们还需要进行逆变换。而事实上, 快速傅里叶逆变换与快速傅里叶变换在形式上非常相像, 这里用线性代数及拉格朗日插值 (Lagrange polynomial) 来证明。</p>
<p>考虑分别用列向量 $\mathbf{A}=[a_0\ a_1\ a_2\ \cdots\ a_{n-1}]^{\intercal}, \mathbf{Y}=[y_0\ y_1\ y_2\ \cdots\ y_{n-1}]^{\intercal}$ 表示多项式及其离散傅里叶变换, 那么这个变换过程相当于 $\mathbf{A}$ 左乘一个 $n$ 阶方阵 $\mathbf{T}$, 有<br>$$<br>\begin{bmatrix}<br>    y_0\\<br>    y_1\\<br>    y_2\\<br>    \vdots\\<br>    y_{n-1}<br>\end{bmatrix}=<br>\begin{bmatrix}<br>    1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\<br>    1 &amp; \omega_n &amp; \omega_n^2 &amp; \cdots &amp; \omega_n^{n - 1}\\<br>    1 &amp; \omega_n^2 &amp; \omega_n^4 &amp; \cdots &amp; \omega_n^{2(n - 1)}\\<br>    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>    1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \cdots &amp; \omega_n^{(n - 1)^2}<br>\end{bmatrix}<br>\begin{bmatrix}<br>    a_0\\<br>    a_1\\<br>    a_2\\<br>    \vdots\\<br>    a_{n-1}<br>\end{bmatrix}<br>$$<br>上式可表达成 $\mathbf{Y}=\mathbf{T}\times \mathbf{A}$, 则有 $\mathbf{A}=\mathbf{T}^{-1}\times \mathbf{Y}$, 即逆变换相当于 $\mathbf{Y}$ 左乘 $n$ 阶方阵 $\mathbf{T}$ 的逆。其中 $\mathbf{T}$ 称为范德蒙矩阵 (Vandermonde matrix), 其有一个绝妙的性质。</p>
<blockquote>
<p>定理</p>
<p>对于 $n$ 阶方阵 $\mathbf{T}=$<br>$$<br>\begin{bmatrix}1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\1 &amp; \omega_n &amp; \omega_n^2 &amp; \cdots &amp; \omega_n^{n - 1}\\1 &amp; \omega_n^2 &amp; \omega_n^4 &amp; \cdots &amp; \omega_n^{2(n - 1)}\\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \cdots &amp; \omega_n^{(n - 1)^2}\end{bmatrix}<br>$$<br>其的逆 $\mathbf{T}^{-1}=$<br>$$<br>\frac{1}{n}\begin{bmatrix}1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\1 &amp; \omega_n^{-1} &amp; \omega_n^{-2} &amp; \cdots &amp; \omega_n^{-(n - 1)}\\1 &amp; \omega_n^{-2} &amp; \omega_n^{-4} &amp; \cdots &amp; \omega_n^{-2(n - 1)}\\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\1 &amp; \omega_n^{-(n-1)} &amp; \omega_n^{-2(n-1)} &amp; \cdots &amp; \omega_n^{-(n - 1)^2}\end{bmatrix}<br>$$<br>即原方阵的每一项取倒数, 再除以 $n$。</p>
</blockquote>
<blockquote>
<p>证明</p>
<p>考虑这个逆变换在做什么。它将 $n$ 个点依次插值得到系数表达, 考虑拉格朗日插值基函数 (Lagrange basis polynomials)<br>$$<br>f(x)=\sum_{i=0}^{n-1}y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}<br>$$<br>分析可知,<br>$$<br>\mathbf{T}^{-1}[i,j]=[x^j]\prod_{k\neq i}\frac{x-x_k}{x_i-x_k}=[x^j]\frac{\prod\limits_{k\neq i}x-x_k}{\prod\limits_{k\neq i}x_i-x_k}<br>$$<br>设 $\lambda(x)=\prod\limits_{i=0}^{n-1}x-\omega_n^i=x^n-1$, 则根据洛必达法则 (L’Hôpital’s rule), 分母<br>$$<br>\prod_{k\neq i}x_i-x_k=\lim_{x\to \omega_n^i}\frac{\lambda(x)}{x-\omega_n^i}=\lim_{x\to \omega_n^i}\lambda’(x)=n\times \omega_n^{i(n-1)}=n\times \omega_n^{-i}<br>$$<br>根据泰勒级数 (Taylor series), 分子<br>$$<br>\begin{aligned}\prod_{k\neq i}x-x_j&amp;=\frac{\lambda(x)}{x-\omega_n^i}=\frac{x^n-1}{x-\omega_n^i}=\omega_n^{-i}\left(\frac{x^n}{1-x\omega_n^{-i}}-\frac{1}{1-x\omega_n^{-i}}\right)\\&amp;=\omega_n^{-i}\left(\sum_{j=0}^{\infty}\omega_n^{-i(j-n)}x^j-\sum_{j=0}^{\infty}\omega_n^{-ij}x^j\right)=\omega_n^{-i}\sum_{j=0}^{n-1}\omega_n^{-ij}x^j\end{aligned}<br>$$<br>则原式<br>$$<br>\mathbf{T}^{-1}[i,j]=[x^j]\frac{\omega_n^{-i}\sum_{j=0}^{n-1}\omega_n^{-ij}x^j}{n\times \omega_n^{-i}}=\frac{\omega_n^{-ij}}{n}<br>$$</p>
</blockquote>
<p>至此, 这和快速傅里叶变换的差别仅仅只有一处, 即 $\omega_n$ 的取值。</p>
<h2 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h2><p>在快速傅里叶变换的实现过程中, 由于引入了三角函数, 使得存在大量的浮点数运算, 在数据规模较大时误差是难以避免的。快速数论变化 (Number-theoretic transform, NTT) 的范德蒙矩阵将全部取到整数, 即不牵涉浮点数运算, 确保了精度。</p>
<h3 id="阶与原根"><a href="#阶与原根" class="headerlink" title="阶与原根"></a>阶与原根</h3><p>在快速傅里叶变换时, 我们在求解方程 $x^n=1$ 时引入了复数, 这里同理可以想到求解同余方程 $x^n\equiv 1\pmod p$, 据此我们可以自然地引入原根。</p>
<p>根据原根的性质, 对于原根 $g$, $g^t$ 每 $\varphi(p)$ 一周期, 故我们要满足 $n=2^m|\varphi(p)$, 考虑 $p$ 取 $q\times 2^m+1$ 且 $p$ 是质数, 常见的大质数有<br>$$<br>\begin{aligned}<br>    p=998244353&amp;=7\times 17\times 2^{23}+1\to g=3\\<br>    p=1004535809&amp;=479\times 2^{21}+1\to g=3<br>\end{aligned}<br>$$</p>
<p>同样, 类似于单位复根的概念, 定义 $\left(g_n^k\right)^n=1(k\in[0,n-1])$, 为了满足单位复根周期性的性质, 可以得到 $g_n=g^{\frac{p-1}{n}}$, 那么, 这里的 $g_n^k$ 可以对应于快速傅里叶变换中的 $\omega_n^k$。接下来我们证明 $g_n$ 与 $\omega_n$ 具有同样的性质。</p>
<blockquote>
<p>定理</p>
<p>$g_n^{n/2}=-1,g_n^k=-g_n^{k+n/2},\left(g_n^k\right)^2=g_{n/2}^k$</p>
</blockquote>
<blockquote>
<p>证明</p>
<p>$\left(g_n^{n/2}\right)^2=g_n^n=1\implies g_n^{n/2}=\pm 1$。</p>
<p>根据阶的性质, $a^n=1\implies p-1|n$。</p>
<p>故 $g_n^{n/2}\neq 1\implies g_n^{n/2}=-1$。</p>
<p>$g_n^{k+n/2}=g_n^{n/2}\times g_n^k=-g_n^k$。$\left(g_n^k\right)^2=\left(g^{\frac{p-1}{n/2}}\right)^k=g_{n/2}^k$。</p>
</blockquote>
<p>至此, 我们也只要将快速傅里叶变换的单位根的取值做出改动, 在 $p$ 的模意义运算即可得到快速数论变换。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在算法竞赛中, 涉及线性变换的题目层出不穷, 下面通过一道经典例题来感受这一经典算法。</p>
<blockquote>
<p>求 $n$ 个点的有标号无向连通图个数。$n\le 10^5$。</p>
</blockquote>
<p>首先设 $f(n)$ 表示 $n$ 个点无向图的个数, 由于每条边可以连或不连, 则 $f(n)=2^{\frac{n(n-1)}{2}}$。设 $g(n)$ 表示 $n$ 个点的有标号无向连通图个数, 即答案。考虑枚举与 1 号节点相连的联通块大小, 剩下点可以任意连边, 同时还需乘上组合数, 则有<br>$$<br>f(n)=\sum_{i=1}^n \binom{n-1}{i-1}g(i)f(n-i)<br>$$</p>
<p>展开得到<br>$$<br>2^{\frac{n(n-1)}{2}}=\sum_{i=1}^n\frac{(n-1)!}{(i-1)!(n-i)!}g(i)\times 2^{\frac{(n-i)(n-i-1)}{2}}<br>$$<br>$$<br>\frac{g(n)}{(n-1)!}=\frac{2^{\frac{n(n-1)}{2}}}{(n-1)!}-\sum_{i=1}^{n-1}\frac{g(i)}{(i-1)!}\times \frac{2^{\frac{(n-i)(n-i-1)}{2}}}{(n-i)!}<br>$$</p>
<p>初始时 $g(1)=1$, 这样直接暴力转移可以做到 $\Theta(n^2)$, 由于这显然是一个卷积的性质, 可以用 FFT 优化, 但我们并不知道 $g(i)$ 的值, 考虑 CDQ 分治, 计算出前 $\dfrac n2$ 项对后 $\dfrac n2$ 项的贡献, 时间复杂度 $T(n)=2T\left(\dfrac n2\right)+\Theta(n\log n)=\Theta\left(n\log^2 n\right)$。</p>
<p>通过这道例题, 我们可以发现 FFT 相关算法可以作为优化计数题时间复杂度的重要手段, 同时也会与其他算法相结合。但事实上, 就笔者的经验来说, 推出递推式和化简才是计数题的难点和重中之重, FFT/NTT 仅能作为锦上添花的辅助手段。</p>
<p><strong>声明</strong>：本文摘自本人学校由本人所作的探究性学习，作者均为本人，详情可 <a href="mailto:Henry__Chen@outlook.com">E-mail</a>。</p>
]]></content>
  </entry>
  <entry>
    <title>IOI 2018 Day1 T3 Werewolf Solution</title>
    <url>/ioi18-d1t3/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定无向联通图，$q$ 次询问 $s,t,l,r$，求是否存在一个点 $p$，使得 $s\rightarrow p $ 的路径上所经过点的编号 $\ge l$，且 $p \rightarrow t$ 的路径上所经过点的编号 $\le r$。</p>
<p>$n\le 2\times 10^5,m\le 4\times 10^5$</p>
<span id="more"></span>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>容易发现，前半部分的约束相当于所经过点编号的最小值 $\ge l$，后半部分同理，和瓶颈路十分类似。</p>
<blockquote>
<p>瓶颈路：求一条 $s\rightarrow t $ 的路径，使得其中经过的边权最小值最大或最大值最小。</p>
</blockquote>
<h3 id="Kruskal-重构树"><a href="#Kruskal-重构树" class="headerlink" title="Kruskal 重构树"></a>Kruskal 重构树</h3><p>当我们用 Kruskal 求图上的最小生成树时，我们可以在合并两个森林时新建一个点，并令这个点的点权为当前边的边权，将两个森林合并到这个点上，这样所构造出来的一棵树称为 Kruskal 重构树。</p>
<p>根据最小生成树的性质，在原图上任取两个点 $u,v$，这两个点的最小瓶颈路上的最大边权即为重构树上 $\text{LCA}(u,v)$ 上的点权。</p>
<p>就本题而言，借助 Kruskal 重构树的思想，构造以点编号为关键字的重构树，满足点的编号随树深度的递增而递增或递减。</p>
<p>例如，对于左半部分的重构树，可以 $1\sim n$ 遍历每一个点 $u$，如果相连的点的编号 $v$ 小于 $u$ 则将 $u$ 的祖先置为 $v$。那么在这棵重构树上，$s$ 不断向上倍增找到一个编号最小的且编号 $\ge l$ 的祖先 $fa$，从而 $s$ 可以在 $l$ 的限制下到达 $fa$ 子树的所有点。</p>
<p>至此，问题转化为两个子树内的点是否有交集。</p>
<p>有一种离线做法，即将求交集看作二维数点，用树状数组维护即可做到 $O(n\log n)$。现在介绍一种在线做法。</p>
<h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><p>主席树通过记录历史版本可以容易地维护区间中的序列信息，具体详见 OI wiki 中的介绍：<a href="https://oi-wiki.org/ds/persistent-seg/">可持久化线段树 OI-Wiki</a>。</p>
<p>由于子树内的 dfs 序是连续的，可以通过在主席树中插入两个点的唯一映射 $(i,dfn2[rnk1[i])$，查询时直接判断区间内点的数量是否大于 $0$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, Q, head[MAXN], nxt[MAXN &lt;&lt; <span class="number">2</span>], ver[MAXN &lt;&lt; <span class="number">2</span>], rt[MAXN &lt;&lt; <span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    nxt[++head[<span class="number">0</span>]] = head[u];</span><br><span class="line">    ver[head[u] = head[<span class="number">0</span>]] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[MAXN], fa[MAXN][<span class="number">21</span>], dfn[MAXN], sz[MAXN], rnk[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> mark;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; e[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; mark; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j; j = nxt[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ver[j] &gt; i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> u = <span class="built_in">find</span>(i), v = <span class="built_in">find</span>(ver[j]);</span><br><span class="line">                <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">                f[v] = u;</span><br><span class="line">                e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &amp;&amp; !mark; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j; j = nxt[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ver[j] &lt; i) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">int</span> u = <span class="built_in">find</span>(i), v = <span class="built_in">find</span>(ver[j]);</span><br><span class="line">                <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">                f[v] = u;</span><br><span class="line">                e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> _fa)</span> </span>&#123;</span><br><span class="line">        rnk[dfn[u] = ++dfn[<span class="number">0</span>]] = u;</span><br><span class="line">        sz[u] = <span class="number">1</span>;</span><br><span class="line">        fa[u][<span class="number">0</span>] = _fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">            fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_fa == v) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; ~i &amp;&amp; mark; i--)</span><br><span class="line">            <span class="keyword">if</span> (fa[x][i] &amp;&amp; fa[x][i] &lt;= k) x = fa[x][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; ~i &amp;&amp; !mark; i--)</span><br><span class="line">            <span class="keyword">if</span> (fa[x][i] &amp;&amp; fa[x][i] &gt;= k) x = fa[x][i];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T1, T2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persistent_Segment_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[MAXN &lt;&lt; <span class="number">6</span>], tol, ls[MAXN &lt;&lt; <span class="number">6</span>], rs[MAXN &lt;&lt; <span class="number">6</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;pre)</span> </span>&#123;</span><br><span class="line">        x = ++tol;</span><br><span class="line">        val[x] = val[pre] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= mid) rs[x] = rs[pre], <span class="built_in">insert</span>(ls[x], l, mid, p, ls[pre]);</span><br><span class="line">        <span class="keyword">else</span> ls[x] = ls[pre], <span class="built_in">insert</span>(rs[x], mid + <span class="number">1</span>, r, p, rs[pre]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; ll || l &gt; rr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> val[R] - val[L];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(ls[L], ls[R], l, mid, ll, rr) + <span class="built_in">query</span>(rs[L], rs[R], mid + <span class="number">1</span>, r, ll, rr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io &gt;&gt; n &gt;&gt; m &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">        io &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        u++; v++;</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    T1.mark = <span class="literal">false</span>; T2.mark = <span class="literal">true</span>;</span><br><span class="line">    T1.<span class="built_in">build</span>(); T2.<span class="built_in">build</span>();</span><br><span class="line">    T1.<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); T2.<span class="built_in">dfs</span>(n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        st.<span class="built_in">insert</span>(rt[i], <span class="number">1</span>, n, T2.dfn[T1.rnk[i]], rt[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s, t, l, r; Q--;) &#123;</span><br><span class="line">        io &gt;&gt; s &gt;&gt; t &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        s++; t++; l++; r++;</span><br><span class="line">        <span class="keyword">int</span> x = T1.<span class="built_in">calc</span>(s, l), y = T2.<span class="built_in">calc</span>(t, r);</span><br><span class="line">        io &lt;&lt; (st.<span class="built_in">query</span>(rt[T1.dfn[x] - <span class="number">1</span>], rt[T1.dfn[x] + T1.sz[x] - <span class="number">1</span>], <span class="number">1</span>, n, T2.dfn[y], T2.dfn[y] + T2.sz[y] - <span class="number">1</span>) &gt; <span class="number">0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>学习笔记——莫比乌斯反演</title>
    <url>/mobius/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>莫比乌斯反演是数论内容的一个重要的分支，通常用于求一些不好直接求解的数论函数。</p>
<span id="more"></span>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>若无特别说明，$p$ 表示质数。</p>
<h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><p>对于一个数论函数 $f(n)$，如果满足 $f(xy)=f(x)f(y)$，其中$\text{gcd}(x,y)=1$，则称 $f(n)$ 为积性函数。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>若 $f(n), g(n)$ 为积性函数，则下列函数均为积性函数。</p>
<ul>
<li>$h(n)=f(n)g(n)$</li>
<li>$h(n)=f(n^p)$</li>
<li>$h(n)=\sum\limits_{d|n}f(d)g(\dfrac{n}{d})$</li>
</ul>
<h4 id="常见的积性函数"><a href="#常见的积性函数" class="headerlink" title="常见的积性函数"></a>常见的积性函数</h4><ul>
<li>$1(n) = 1$</li>
<li>$\epsilon(n)=[n=1]$ （读作 [ˈepsɪlɑːn]）</li>
<li>$I(n)=n$</li>
<li>$id_k(n)=n^k$</li>
<li>$\sigma_k(n)=\sum_{d|n}d^k$</li>
<li>$$<br>\varphi(n) = n\prod_{p|n}(1-\dfrac{1}{p})<br>$$</li>
<li>$$<br>\mu(n)=\begin{cases}<br>1&amp;(n=1)\\<br>(-1)^k&amp;n=\prod\limits_{i=1}^k p_i\\<br>0&amp;(\text{otherwise})<br>\end{cases}<br>$$</li>
</ul>
<h2 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h2><p>对于式子<br>$$<br>\sum_{i=1}^n\left\lfloor\dfrac{n}{i}\right\rfloor<br>$$<br>可以通过分块的方式在 $O(\sqrt{n})$ 求得。<br>发现 $\left\lfloor\dfrac{n}{i}\right\rfloor$ 最多有 $ \sqrt{n}$ 种取值，将相同的$\left\lfloor\dfrac{n}{i}\right\rfloor$一起处理，即设当前块左端点为 $L$，则右端点  $R=\left\lfloor\dfrac{n}{\left\lfloor\dfrac{n}{L}\right\rfloor}\right\rfloor$。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>, gx; x &lt;= n; x = gx + <span class="number">1</span>) &#123;</span><br><span class="line">    gx = n / (n / x);</span><br><span class="line">    ans += (gx - x + <span class="number">1</span>) * (gx + x) / <span class="number">2</span> * (n / x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>(gx - x + 1) * (gx + x) / 2</code> 为<del>小学学过的</del>公差为 $1$ 等差数列求和。</p>
<h3 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h3><p>对于数论函数 $f,g$ ,其卷积为<br>$$<br>(f*g)(n)=\sum_{d|n}f(d)g(\dfrac{n}{d})<br>$$<br>且满足</p>
<ul>
<li>交换律 $f\ast g=g\ast f$</li>
<li>结合律 $(f\ast g)\ast h=f\ast (g\ast h)$</li>
<li>分配律 $f\ast g+f\ast h=f\ast (g+h)$</li>
</ul>
<h4 id="常见等式"><a href="#常见等式" class="headerlink" title="常见等式"></a>常见等式</h4><ul>
<li>$\sigma_0=1\ast 1$</li>
<li>$\sigma_1=I\ast 1$</li>
<li>$\epsilon=\mu \ast  1$</li>
<li>$I=\varphi\ast 1$</li>
<li>$\varphi=I\ast \mu$</li>
</ul>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>$$<br>f = g \ast  1 \Leftrightarrow g = f \ast  \mu<br>$$<br>即<br>$$<br>f(n) = \sum_{d|n}g(d) \Leftrightarrow g(n)=\sum_{d|n}f(d)\mu(\dfrac{n}{d})<br>$$</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>若无特别说明，假定 $n \le m$。</p>
<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>多组询问，求<br>$$<br>\sum_{i=1}^n\sum_{j=1}^m[\text{gcd}(i,j)=1]<br>$$<br>其中 $T \le 10^4, n,m \le 10^7$。</p>
<p>由 $\epsilon=\mu \ast  1$ 可知<br>$$<br>= \sum_{i=1}^n\sum_{j=1}^m\sum_{d|\text{gcd}(i,j)}\mu(d)<br>$$<br>改变枚举顺序，先枚举 $d$，并由 $d|\text{gcd}(i,j)$ 可知，$d|i$ 且 $d|j$，则<br>$$<br>= \sum_{d=1}^n\mu(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}1<br>$$</p>
<p>$$<br>=\sum_{d=1}^n\mu(d)\left\lfloor\dfrac{n}{d}\right\rfloor\left\lfloor\dfrac{m}{d}\right\rfloor<br>$$<br>至此，对于左边，可线性预处理 $\mu(n)$ 的前缀和，对于右边，数论分块即可。时间复杂度为 $O(n+T\sqrt{n})$</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, p[MAXN], cnt, m, d, T; ll mu[MAXN] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;; <span class="keyword">bool</span> v[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN - <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) p[++cnt] = i, mu[i] = - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] * i &lt;= MAXN - <span class="number">5</span>; j++) &#123;</span><br><span class="line">        v[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        mu[i * p[j]] = -mu[i];</span><br><span class="line">    &#125; &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;d); </span><br><span class="line">    <span class="keyword">if</span> (m &gt; n) std::<span class="built_in">swap</span>(m, n); ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>, gx; x &lt;= m; x = gx + <span class="number">1</span>) &#123;</span><br><span class="line">        gx = std::<span class="built_in">min</span>(m / (m / x), n / (n / x));</span><br><span class="line">        sum += (mu[gx] - mu[x - <span class="number">1</span>]) * (m / x / d) * (n / x / d);</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="II"><a href="#II" class="headerlink" title="II"></a>II</h3><p>多组询问，求<br>$$<br>\sum_{i=1}^n\sum_{j=1}^m\text{gcd}(i,j)<br>$$<br>其中 $T \le 10^4, n,m \le 10^7$<br>由 $I=\varphi \ast  1$，得<br>$$<br>= \sum_{i=1}^n\sum_{j=1}^m\sum_{d|\text{gcd}(i,j)}\varphi(d)<br>$$<br>同 I，最后可得<br>$$<br>=\sum_{d=1}^n\varphi(d)\left\lfloor\dfrac{n}{d}\right\rfloor\left\lfloor\dfrac{m}{d}\right\rfloor<br>$$<br>做法和时间复杂度同 I</p>
<h3 id="III"><a href="#III" class="headerlink" title="III"></a>III</h3><p>多组询问，求<br>$$<br>\sum_{i=1}^n\sum_{j=1}^m[\text{gcd}(i,j)=d]<br>$$<br>其中 $T \le 10^4, n,m,d \le 10^7$<br>考虑将 $d$ 变为 $1$ 后再进行转化。由最大公约数的定义可知 $\text{gcd}(\dfrac{i}{d},\dfrac{j}{d})=1$，也就相当于 $i,j$ 枚举的上界发生了变化，可得<br>$$<br>=\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}[\text{gcd}(i,j)=1]<br>$$<br>同 I，最后亦可得<br>$$<br>=\sum_{x=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(x)\left\lfloor\dfrac{n}{xd}\right\rfloor\left\lfloor\dfrac{m}{xd}\right\rfloor<br>$$<br>做法和时间复杂度同 I</p>
<h3 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h3><p>多组询问，求<br>$$<br>\sum_{i=1}^n\sum_{j=1}^m\text{lcm}(i,j)<br>$$<br>其中 $T \le 10^4, n,m \le 10^7$<br>由<del>小学学过的</del> $(a, b)\times[a,b]=a\times b$ 可知<br>$$<br>=\sum_{i=1}^n\sum_{j=1}^m\dfrac{ij}{\text{gcd}(i,j)}<br>$$<br>设 $d=\text{gcd}(i,j),i=i’d, j=j’d$，显然有 $\text{gcd}(i’,j’)=1$，则<br>$$<br>=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,d|j,\text{gcd}(i’,j’)=1}\dfrac{ij}{d}<br>$$</p>
<p>$$<br>=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,d|j,\text{gcd}(i’,j’)=1}i’j’d<br>$$<br>同 I，改变枚举顺序，先枚举 $d$，则有（为书写美观，记 $i=i’,j=j’$）<br>$$<br>=\sum_{d=1}^nd\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}[\text{gcd}(i,j)=1]ij<br>$$<br>同理<br>$$<br>=\sum_{d=1}^nd\sum_{x=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(x)\sum_{x|i}\sum_{x|j}ij<br>$$<br>再设 $i=i’’x,j=j’’x$，则有<br>$$<br>=\sum_{d=1}^nd\sum_{x=1}^{\left\lfloor\frac{n}{d}\right\rfloor}x^2\mu(x)\sum_{i’’=1}^{\left\lfloor\frac{n}{xd}\right\rfloor}\sum_{j’’=1}^{\left\lfloor\frac{m}{xd}\right\rfloor}i’’j’’<br>$$<br>不妨设 $f(n)=\sum\limits_{i=1}^ni=\dfrac{n(n+1)}{2}$，则有<br>$$<br>=\sum_{d=1}^nd\sum_{x=1}^{\left\lfloor\frac{n}{d}\right\rfloor}x^2\mu(x)f(\left\lfloor\dfrac{n}{xd}\right\rfloor)f(\left\lfloor\frac{m}{xd}\right\rfloor)<br>$$<br>至此，可以线性预处理 $f(n)$ 和 $g(n)=\sum\limits_{i=1}^{n}i^2\mu(i)$ 的前缀和。再通过数论分块即可解决。时间复杂度同 I。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, cnt, ans;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], p[MAXN], sum[MAXN];</span><br><span class="line"><span class="keyword">bool</span> v[MAXN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) v[i] = <span class="number">1</span> , f[i] = (<span class="number">1</span> - i + MOD) % MOD, p[++cnt] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] * i &lt;= n; j++) &#123;</span><br><span class="line">        v[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % p[j]) f[i * p[j]] = <span class="number">1ll</span> * f[i] * f[p[j]] % MOD;</span><br><span class="line">        <span class="keyword">else</span> &#123;f[i * p[j]] = f[i]; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125; &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    f[i] = (f[i - <span class="number">1</span>] + <span class="number">1ll</span> * i * f[i] % MOD) %MOD, sum[i] = (<span class="number">1ll</span> * sum[i - <span class="number">1</span>] + i) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>, gx; x &lt;= m; x = gx + <span class="number">1</span>) &#123;</span><br><span class="line">    gx = <span class="built_in">min</span>(m / (m / x), n / (n / x));</span><br><span class="line">    ans = (ans + <span class="number">1ll</span> * (f[gx] - f[x - <span class="number">1</span>] + MOD) % MOD * sum[n / x] % MOD * sum[m / x] % MOD) % MOD;</span><br><span class="line">&#125; <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="LG2257"><a href="#LG2257" class="headerlink" title="LG2257"></a><a href="https://www.luogu.com.cn/problem/P2257">LG2257</a></h3><p>多组数据，求<br>$$<br>\sum_{p\in\text{prime}}\sum_{i=1}^n\sum_{j=1}^m[\text{gcd}(i,j)=p]<br>$$<br>其中 $T \le 10^4, n,m \le 10^7$。<br>由应用 III 可得<br>$$<br>=\sum_{p\in\text{prime}}\sum_{x=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\mu(x)\left\lfloor\dfrac{n}{xp}\right\rfloor\left\lfloor\dfrac{m}{xp}\right\rfloor<br>$$<br>设 $T = xp$，可得 $p|T$，改变枚举顺序，先枚举 $T$，可得<br>$$<br>=\sum_{T=1}^n\sum_{p|T, p \in \text{prime}}\mu(\dfrac{T}{P})\left\lfloor\dfrac{n}{T}\right\rfloor\left\lfloor\dfrac{m}{T}\right\rfloor<br>$$</p>
<p>$$<br>=\sum_{T=1}^n \left\lfloor\dfrac{n}{T}\right\rfloor\left\lfloor\dfrac{m}{T}\right\rfloor\sum_{p|T, p \in prime}\mu(\dfrac{T}{P})<br>$$<br>至此，右边可以枚举质数的倍数，左边数论分块即可。时间复杂度为 $ O(n + \pi(n)\ln n + T\sqrt{n})$。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[MAXN], mu[MAXN] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, cnt, f[MAXN];</span><br><span class="line"><span class="keyword">bool</span> v[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN - <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) mu[i] = <span class="number">-1</span>, p[++cnt] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= MAXN - <span class="number">5</span>; j++) &#123;</span><br><span class="line">        v[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125; &#125;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * p[i] &lt;= MAXN - <span class="number">5</span>; j++) f[j * p[i]] += mu[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAXN - <span class="number">5</span>; i++) f[i]+= f[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> T = <span class="built_in">read</span>(); </span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(); ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) n ^= m ^= n ^= m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, gx; i &lt;= n; i = gx + <span class="number">1</span>) &#123;</span><br><span class="line">        gx = <span class="built_in">min</span>(n / (n / i), m / (m / i));</span><br><span class="line">        ans += <span class="number">1ll</span> * (f[gx] - f[i - <span class="number">1</span>]) * (n / i) * (m / i);</span><br><span class="line">    &#125; <span class="built_in">write</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CF1139D"><a href="#CF1139D" class="headerlink" title="CF1139D"></a><a href="https://www.luogu.com.cn/problem/CF1139D">CF1139D</a></h3><p>对一个数列不断添加 $[1,n]$ 的数，直到数列中所有数的 $\text{gcd}=1$ 为止，求期望长度。$n \le 10^5$。</p>
<p>考虑 $\text{dp}$，设 $f_i$ 为当前数列 $\text{gcd}=i$ 时变为 $\text{gcd}=1$ 所用的期望次数。显然 $f_1=0$。则答案<br>$$<br>ans=\dfrac{1}{n}\sum_{i=1}^nf_i+1<br>$$<br>其中 $1$ 为第一个数就为 $1$ 的情况，然后枚举 $[2,n]$ 的数，每一个数都有 $\dfrac{1}{n}$ 的概率选到。<br>考虑状态转移方程<br>$$<br>f_i=\dfrac{1}{n}\sum_{j=1}^{n}f_{\text{gcd}(i,j)}+1<br>$$<br>其中 $1$ 表示转移时的贡献，再枚举下一个数，则所对应的状态为 $f_{\text{gcd}(d,i)}$，而每一个数都有 $\dfrac{1}{n}$ 的概率选到。<br>考虑莫比乌斯反演，先枚举 $d=\text{gcd}(i, j)$，化分母得<br>$$<br>nf_i=\sum_{d|i}f_d\sum_{j=1}^{n}[\text{gcd}(i,j)=d]+n<br>$$<br>由应用 III，<br>$$<br>nf_i=\sum_{d|i}f_d\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}[\text{gcd}(\dfrac{i}{d},j)=1]+n<br>$$</p>
<p>$$<br>nf_i=\sum_{d|i}f_d\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{x|\text{gcd}(\frac{i}{d},j)}\mu(x)+n<br>$$</p>
<p>$$<br>nf_i=\sum_{d|i}f_d\sum_{x=1}^n\mu(x)\left\lfloor\dfrac{n}{xd}\right\rfloor+n<br>$$<br>设 $T=xd$，改变枚举顺序，先枚举 $T$ 得<br>$$<br>nf_i=\sum_{T|i}\left\lfloor\dfrac{n}{T}\right\rfloor\sum_{d|T}f_d\mu(\dfrac{T}{d})+n<br>$$<br>特别的，当 $T=d=i$ 时，等式右边含有未知量，考虑将其移至左边<br>$$<br>nf_i=\sum_{T|i}\left\lfloor\dfrac{n}{T}\right\rfloor\sum_{d|T,d\not=i}f_d\mu(\dfrac{T}{d})+n + \mu(1)f_i\left\lfloor\dfrac{n}{i}\right\rfloor<br>$$</p>
<p>$$<br>(n-\left\lfloor\dfrac{n}{i}\right\rfloor)f_i=\sum_{T|i}\left\lfloor\dfrac{n}{T}\right\rfloor\sum_{d|T,d\not=i}\mu(\dfrac{T}{d})f_d+n<br>$$<br>至此，可以预处理每一个数的因子和 $\mu(n)$ 的前缀和，递推即可。此外，由于涉及到除法运算，要线性预处理逆元。时间复杂度为 $O(n\log^2n)$</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, v[MAXN], p[MAXN], mu[MAXN], m, inv[MAXN], f[MAXN], ans;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; a[MAXN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); mu[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) p[++m] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; i * p[j] &lt;= n; j++) &#123;</span><br><span class="line">        v[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125; &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) a[j].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) inv[i] = <span class="number">1ll</span>* (P - P / i) * inv[P % i] % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>, sz = a[i].<span class="built_in">size</span>(); j &lt; sz; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> T = a[i][j], res1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, sz1 = a[T].<span class="built_in">size</span>(); k &lt; sz1; k++)</span><br><span class="line">            <span class="keyword">if</span> (a[T][k] != i)</span><br><span class="line">                res1 = (<span class="number">1ll</span> * res1 + mu[T / a[T][k]] * f[a[T][k]] + P) % P;</span><br><span class="line">        f[i] = (f[i] + <span class="number">1ll</span> * res1 * (n / T) % P) % P;</span><br><span class="line">    &#125; f[i] = <span class="number">1ll</span> * f[i] * inv[n - n / i] % P;</span><br><span class="line">    ans = (ans + f[i]) % P;</span><br><span class="line">&#125; <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, <span class="number">1ll</span> * ans * inv[n] % P +<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Another-Solution"><a href="#Another-Solution" class="headerlink" title="Another Solution"></a>Another Solution</h4><p>$$<br>\begin{aligned}<br>E(X)&amp;=\sum_{i\ge 1}P(X=i)i\<br>&amp;=\sum_{i\ge 1}P(X=1)\sum_{j=1}^i1\<br>&amp;=\sum_{j\ge 1}\sum_{i\ge j}P(X=i)\<br>&amp;=\sum_{i\ge 1}P(X\ge i)\<br>&amp;=1-\sum_{i\ge 1}P(X&gt;i)<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>P(X&gt;1)&amp;=1-P(X=1)\<br>&amp;=1-\dfrac{[\sum\cdots\sum gcd=1]}{m^i}<br>&amp;=1-\dfrac{\sum\mu(d)\left\lfloor\frac md\right\rfloor^i}{m^i}<br>\end{aligned}<br>$$</p>
<h3 id="LG4449"><a href="#LG4449" class="headerlink" title="LG4449"></a><a href="https://www.luogu.com.cn/problem/P4449">LG4449</a></h3><p>求<br>$$<br>\sum_{i=1}^n\sum_{j=1}^m\text{gcd}(i,j)^k<br>$$<br>其中 $T \le 10^3, n,m,k \le 10^6$</p>
<p>设 $id_k = f(n) \ast  1$，则 $f(n) = id_k \ast  \mu$，得到<br>$$<br>=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|\text{gcd}(i,j)}f(d)<br>$$<br>由应用 I，得<br>$$<br>=\sum_{d=1}^nf(d)\left\lfloor\dfrac{n}{d}\right\rfloor\left\lfloor\dfrac{m}{d}\right\rfloor<br>$$</p>
<p>$$<br>=\sum_{d=1}^n\sum_{x|d}x^k\mu(\dfrac{d}{x})\left\lfloor\dfrac{n}{d}\right\rfloor\left\lfloor\dfrac{m}{d}\right\rfloor<br>$$</p>
<p>$$<br>=\sum_{d=1}^n\left\lfloor\dfrac{n}{d}\right\rfloor\left\lfloor\dfrac{m}{d}\right\rfloor\sum_{x|d}x^k\mu(\dfrac{d}{x})<br>$$<br>至此，由于右半部分相当于 $f(d)$，是一个积性函数，可以在线性时间内求值并算出前缀和。左半部分可以用数论分块求得。时间复杂度为 $O((n + T\sqrt{n})\log k)$。<br>$$<br>f(x)=\begin{cases}1&amp;x=1\\p^k-1&amp;p\in\text{prime}\end{cases}<br>$$</p>
<p>$$<br>f(xp)=\begin{cases}f(x)f(p)&amp;\text{gcd}(x,p)=1\\p^kf(x)&amp;\text{gcd}(x,p)\not=1\end{cases}\quad  p\in\text{prime}<br>$$</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k, T, v[MAXN], p[MAXN], m; ll f[MAXN];</span><br><span class="line"><span class="built_in">read</span>(T, k); f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN - <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) p[++m] = i, f[i] = (<span class="built_in">fpow</span>(i, k) - <span class="number">1</span> + MOD) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; p[j] * i &lt;= MAXN - <span class="number">5</span>; j++) &#123;</span><br><span class="line">        v[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            f[i * p[j]] = f[i] * (f[p[j]] + <span class="number">1</span>) % MOD;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; f[i * p[j]] = f[i] * f[p[j]] % MOD;</span><br><span class="line">    &#125; &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN - <span class="number">5</span>; i++) f[i] = (f[i - <span class="number">1</span>] + f[i]) % MOD;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="built_in">read</span>(x, y); ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, gx; i &lt;= x; i = gx + <span class="number">1</span>) &#123;</span><br><span class="line">        gx = <span class="built_in">min</span>(x / (x / i), y / (y / i));</span><br><span class="line">        ans = (ans + (f[gx] - f[i - <span class="number">1</span>] + MOD) % MOD * (x / i) % MOD * (y / i) % MOD) % MOD;</span><br><span class="line">    &#125; <span class="built_in">write</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>NOIP 出题模板（Tex）</title>
    <url>/noip-template/</url>
    <content><![CDATA[<p>模板</p>
<span id="more"></span>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[fontset=windows,12pt,a4paper,UTF8]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;fancyhdr&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;fontspec&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;geometry&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[colorlinks]&#123;hyperref&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;listings&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;makecell&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;multirow&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;tabularx&#125;</span><br><span class="line"><span class="keyword">\geometry</span>&#123;left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm&#125;</span><br><span class="line"><span class="keyword">\providecommand</span>&#123;<span class="keyword">\tightlist</span>&#125;&#123;<span class="keyword">\setlength</span>&#123;<span class="keyword">\itemsep</span>&#125;&#123;0pt&#125;<span class="keyword">\setlength</span>&#123;<span class="keyword">\parskip</span>&#125;&#123;0pt&#125;&#125;</span><br><span class="line"><span class="keyword">\providecommand</span>&#123;<span class="keyword">\sub</span>&#125;[1]&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">$</span> <span class="built_in">$</span> <span class="keyword">\\</span></span><br><span class="line">	<span class="keyword">\fontsize</span>&#123;13pt&#125;&#123;24pt&#125;<span class="keyword">\selectfont</span><span class="keyword">\textbf</span>&#123;【<span class="params">#1</span>】&#125;</span><br><span class="line">	<span class="keyword">\normalsize</span></span><br><span class="line">	<span class="keyword">\phantomsection</span></span><br><span class="line">	<span class="keyword">\addcontentsline</span>&#123;toc&#125;&#123;subsection&#125;&#123;<span class="params">#1</span>&#125;<span class="built_in">$</span> <span class="built_in">$</span><span class="keyword">\vspace</span>*&#123;12pt&#125;<span class="keyword">\par</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\providecommand</span>&#123;<span class="keyword">\bfzh</span>&#125;[1]&#123;<span class="keyword">\CJKunderdot</span>&#123;<span class="keyword">\textbf</span>&#123;<span class="params">#1</span>&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">\providecommand</span>&#123;<span class="keyword">\bfcd</span>&#125;[1]&#123;<span class="keyword">\emph</span>&#123;<span class="keyword">\textbf</span>&#123;<span class="params">#1</span>&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">\providecommand</span>&#123;<span class="keyword">\problem</span>&#125;[2]&#123;</span><br><span class="line">	<span class="keyword">\newpage</span></span><br><span class="line">	<span class="keyword">\pagestyle</span>&#123;fancy&#125;</span><br><span class="line">	<span class="keyword">\lhead</span>&#123;<span class="keyword">\footnotesize</span><span class="keyword">\CName</span>&#125; <span class="keyword">\rhead</span>&#123;<span class="keyword">\footnotesize</span> <span class="keyword">\TestName</span> <span class="keyword">\ </span><span class="params">#1</span>（<span class="params">#2</span>）&#125;</span><br><span class="line">	<span class="keyword">\cfoot</span>&#123;<span class="keyword">\footnotesize</span> 第 <span class="keyword">\thepage</span> 页 <span class="keyword">\qquad</span> 共 <span class="keyword">\tpage</span> <span class="keyword">\color</span>&#123;black&#125; 页&#125;</span><br><span class="line">	<span class="keyword">\phantomsection</span></span><br><span class="line">	<span class="keyword">\addcontentsline</span>&#123;toc&#125;&#123;section&#125;&#123;<span class="params">#1</span>（<span class="params">#2</span>）&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">		<span class="keyword">\fontsize</span>&#123;18pt&#125;&#123;24pt&#125;</span><br><span class="line">        <span class="keyword">\selectfont</span><span class="keyword">\textbf</span>&#123;<span class="params">#1</span>&#125;（<span class="params">#2</span>）</span><br><span class="line">    <span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line">	<span class="keyword">\normalsize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\lstset</span>&#123;</span><br><span class="line">	basicstyle=&#123;<span class="keyword">\color</span>&#123;black&#125;<span class="keyword">\fontspec</span>&#123;Consolas&#125;&#125;,</span><br><span class="line">	numberstyle=&#123;<span class="keyword">\footnotesize</span><span class="keyword">\color</span>[RGB]&#123;128,128,128&#125;<span class="keyword">\fontspec</span>&#123;Consolas&#125;&#125;,</span><br><span class="line">    keywordstyle=&#123;<span class="keyword">\color</span>&#123;blue&#125;<span class="keyword">\fontspec</span>&#123;Consolas&#125;&#125;,</span><br><span class="line">	rulecolor=<span class="keyword">\color</span>&#123;blue&#125;,</span><br><span class="line">	numbers=left,</span><br><span class="line">	frame=single,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\setmonofont</span>&#123;Consolas&#125;</span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\CName</span>&#123;Name&#125;</span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\TestName</span>&#123;第一试&#125;</span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\CAName</span>&#123;A&#125;</span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\AName</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\CBName</span>&#123;Boy&#125;</span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\BName</span>&#123;boy&#125;</span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\CEName</span>&#123;Third&#125;</span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\EName</span>&#123;third&#125;</span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\tpage</span>&#123;<span class="keyword">\color</span>&#123;blue&#125;&#123;5&#125; &#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\pagestyle</span>&#123;fancy&#125;</span><br><span class="line">	<span class="keyword">\lhead</span>&#123;<span class="keyword">\footnotesize</span> <span class="keyword">\CName</span>&#125; <span class="keyword">\rhead</span>&#123;<span class="keyword">\footnotesize</span><span class="keyword">\TestName</span>&#125;</span><br><span class="line">	<span class="keyword">\cfoot</span>&#123;<span class="keyword">\footnotesize</span> 第 <span class="keyword">\thepage</span> 页 <span class="keyword">\qquad</span> 共 <span class="keyword">\color</span>&#123;blue&#125;<span class="keyword">\tpage</span> <span class="keyword">\color</span>&#123;black&#125; 页&#125;</span><br><span class="line">	<span class="keyword">\thispagestyle</span>&#123;empty&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">		<span class="keyword">\fontsize</span>&#123;22pt&#125;&#123;24pt&#125;<span class="keyword">\selectfont</span><span class="keyword">\textbf</span>&#123;<span class="keyword">\CName</span>&#125;<span class="keyword">\vspace</span>&#123;9pt&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">\fontsize</span>&#123;24pt&#125;&#123;24pt&#125;<span class="keyword">\selectfont</span> CCF NOI 2021<span class="keyword">\vspace</span>&#123;6pt&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">\fontsize</span>&#123;22pt&#125;&#123;24pt&#125;<span class="keyword">\selectfont</span><span class="keyword">\textit</span>&#123;<span class="keyword">\TestName</span>&#125;<span class="keyword">\vspace</span>&#123;6pt&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">\fontsize</span>&#123;15pt&#125;&#123;24pt&#125;<span class="keyword">\selectfont</span><span class="keyword">\textbf</span>&#123;时间：&#125;2021 <span class="keyword">\textbf</span>&#123;年&#125; 1 <span class="keyword">\textbf</span>&#123;月&#125; 1 <span class="keyword">\textbf</span>&#123;日&#125; 08:00 <span class="built_in">$</span><span class="keyword">\sim</span><span class="built_in">$</span> 13:00<span class="keyword">\vspace</span>&#123;12pt&#125;</span><br><span class="line">		<span class="keyword">\normalsize</span></span><br><span class="line">		<span class="keyword">\begin</span>&#123;tabularx&#125;&#123;<span class="keyword">\textwidth</span>&#125;&#123;|X|X|X|X|&#125;</span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		题目名称 <span class="built_in">&amp;</span> <span class="keyword">\CAName</span> <span class="built_in">&amp;</span> <span class="keyword">\CBName</span> <span class="built_in">&amp;</span> <span class="keyword">\CEName</span> <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		题目类型 <span class="built_in">&amp;</span> 交互型 <span class="built_in">&amp;</span> 通信型 <span class="built_in">&amp;</span> 传统型 <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		目录 <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\AName</span>&#125; <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\BName</span>&#125; <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\EName</span>&#125; <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		可执行文件名 <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\AName</span>&#125; <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\BName</span>&#125; <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\EName</span>&#125; <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		输入文件名 <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\AName</span>.in&#125; <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\BName</span>.in&#125; <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\EName</span>.in&#125; <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		输出文件名 <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\AName</span>.out&#125; <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\BName</span>.out&#125; <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\EName</span>.out&#125; <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		每个测试点时限 <span class="built_in">&amp;</span> 1.0 秒 <span class="built_in">&amp;</span> 1.0 秒 <span class="built_in">&amp;</span> 1.0 秒 <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		内存限制 <span class="built_in">&amp;</span> 256 MB <span class="built_in">&amp;</span> 256 MB <span class="built_in">&amp;</span> 512 MB <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		子任务数目 <span class="built_in">&amp;</span> 10 <span class="built_in">&amp;</span> 20 <span class="built_in">&amp;</span> 25 <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		测试点是否等分 <span class="built_in">&amp;</span> 是 <span class="built_in">&amp;</span> 是 <span class="built_in">&amp;</span> 是 <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		<span class="keyword">\end</span>&#123;tabularx&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"></span><br><span class="line">	提交源程序文件名</span><br><span class="line">	<span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">		<span class="keyword">\begin</span>&#123;tabularx&#125;&#123;<span class="keyword">\textwidth</span>&#125;&#123;|X|X|X|X|&#125;</span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		对于 C++ 语言 <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\AName</span>.cpp&#125; <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;<span class="keyword">\BName</span>.cpp&#125; <span class="built_in">&amp;</span><span class="keyword">\texttt</span>&#123;<span class="keyword">\EName</span>.cpp&#125; <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		<span class="keyword">\end</span>&#123;tabularx&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"></span><br><span class="line">	编译选项</span><br><span class="line">	<span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">		<span class="keyword">\newcolumntype</span>&#123;Y&#125;&#123;&gt;&#123;<span class="keyword">\centering</span><span class="keyword">\arraybackslash</span>&#125;X&#125; </span><br><span class="line">		<span class="keyword">\begin</span>&#123;tabularx&#125;&#123;<span class="keyword">\textwidth</span>&#125;&#123;|&gt;&#123;<span class="keyword">\setlength</span>&#123;<span class="keyword">\hsize</span>&#125;&#123;.471<span class="keyword">\hsize</span>&#125;&#125;X|&gt;&#123;<span class="keyword">\setlength</span>&#123;<span class="keyword">\hsize</span>&#125;&#123;1.529<span class="keyword">\hsize</span>&#125;&#125;Y|&#125;</span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		对于 C++ 语言 <span class="built_in">&amp;</span> <span class="keyword">\texttt</span>&#123;-O2&#125; <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\hline</span></span><br><span class="line">		<span class="keyword">\end</span>&#123;tabularx&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">$</span> <span class="built_in">$</span> <span class="keyword">\\</span></span><br><span class="line">	<span class="keyword">\fontsize</span>&#123;13pt&#125;&#123;24pt&#125;<span class="keyword">\selectfont</span><span class="keyword">\textbf</span>&#123;【注意事项（请仔细阅读）】&#125;</span><br><span class="line">	<span class="keyword">\normalsize</span></span><br><span class="line">	<span class="keyword">\phantomsection</span></span><br><span class="line">	<span class="keyword">\addcontentsline</span>&#123;toc&#125;&#123;subsection&#125;&#123;注意事项（请仔细阅读）&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">		<span class="keyword">\tightlist</span></span><br><span class="line">		<span class="keyword">\item</span> 选手提交的源程序必须存放在<span class="keyword">\bfzh</span>&#123;已建立&#125;好的，且<span class="keyword">\bfzh</span>&#123;带有样例文件和下发文件&#125;的文件夹中，文件夹名称与对应试题英文名一致。</span><br><span class="line">		<span class="keyword">\item</span> 文件名（包括程序名和输入输出文件名）必须使用英文小写。</span><br><span class="line">		<span class="keyword">\item</span> C++ 中函数 main() 的返回值类型必须是 int，值必须为 0。</span><br><span class="line">		<span class="keyword">\item</span> <span class="keyword">\bfzh</span>&#123;对于因未遵守以上规则对成绩造成的影响，相关申诉不予受理&#125;。</span><br><span class="line">		<span class="keyword">\item</span> 若无特殊说明，结果比较方式为<span class="keyword">\bfzh</span>&#123;忽略行末空格、文末回车后的全文比较&#125;。</span><br><span class="line">		<span class="keyword">\item</span> 程序可使用的栈空间大小与该题内存空间限制一致。</span><br><span class="line">		<span class="keyword">\item</span> 在终端中执行命令 <span class="keyword">\texttt</span>&#123;ulimit -s unlimited&#125; 可将当前终端下的栈空间限制放大，但你使用的栈空间大小不应超过题目限制。 </span><br><span class="line">		<span class="keyword">\item</span> 每道题目所提交的<span class="keyword">\bfzh</span>&#123;代码文件大小限制为 100KB&#125;。</span><br><span class="line">		<span class="keyword">\item</span> 若无特殊说明，输入文件与输出文件中同一行的相邻整数均使用一个空格分隔。</span><br><span class="line">		<span class="keyword">\item</span> 输入文件中可能存在行末空格，请选手使用更完善的读入方式（例如 scanf 函数）避免出错。</span><br><span class="line">		<span class="keyword">\item</span> 直接复制 PDF 题面中的多行样例，数据将带有行号，建议选手直接使用对应目录下的样例文件进行测试。</span><br><span class="line">		<span class="keyword">\item</span> 使用 std::deque 等 STL 容器时，请注意其内存空间消耗。</span><br><span class="line">		<span class="keyword">\item</span> 请务必使用题面中规定的的编译参数，保证你的程序在本机能够通过编译。此外<span class="keyword">\bfzh</span>&#123;不允许在程序中手动开启其他编译选项&#125;，一经发现，本题成绩以 0 分处理。</span><br><span class="line">	<span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line">	<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">	<span class="keyword">\problem</span>&#123;<span class="keyword">\CAName</span>&#125;&#123;<span class="keyword">\AName</span>&#125;</span><br><span class="line">	<span class="keyword">\bfzh</span>&#123;这是一道交互题。&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">	<span class="keyword">\problem</span>&#123;<span class="keyword">\CBName</span>&#125;&#123;<span class="keyword">\BName</span>&#125;</span><br><span class="line">	<span class="keyword">\bfzh</span>&#123;这是一道通信题。&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">	<span class="keyword">\problem</span>&#123;<span class="keyword">\CEName</span>&#125;&#123;<span class="keyword">\EName</span>&#125;</span><br><span class="line">	<span class="keyword">\sub</span>&#123;题目描述&#125;</span><br><span class="line">	Test</span><br><span class="line"></span><br><span class="line">	<span class="keyword">\sub</span>&#123;输入格式&#125;</span><br><span class="line">	从文件 <span class="keyword">\bfcd</span>&#123;<span class="keyword">\EName</span>.in&#125; 中读入数据。</span><br><span class="line"></span><br><span class="line">	<span class="keyword">\sub</span>&#123;输出格式&#125;</span><br><span class="line">	输出到文件 <span class="keyword">\bfcd</span>&#123;<span class="keyword">\EName</span>.out&#125; 中。</span><br><span class="line"></span><br><span class="line">	<span class="keyword">\sub</span>&#123;样例 1 输入&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;lstlisting&#125;</span><br><span class="line">7 4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">3 4 3</span><br><span class="line">3 5 4</span><br><span class="line">3 6 5</span><br><span class="line">6 7 6</span><br><span class="line">3 2 7 1</span><br><span class="line">5 2 4 7 3 6</span><br><span class="line">2 2 4</span><br><span class="line">1 7</span><br><span class="line">	<span class="keyword">\end</span>&#123;lstlisting&#125;</span><br><span class="line">	<span class="keyword">\sub</span>&#123;样例 1 输出&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;lstlisting&#125;</span><br><span class="line">16</span><br><span class="line">22</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">	<span class="keyword">\end</span>&#123;lstlisting&#125;</span><br><span class="line">	<span class="keyword">\sub</span>&#123;样例 1 解释&#125;</span><br><span class="line"></span><br><span class="line">	Test</span><br><span class="line"></span><br><span class="line">	<span class="keyword">\sub</span>&#123;样例 2&#125;</span><br><span class="line">	见选手目录下的 <span class="keyword">\bfcd</span>&#123;<span class="keyword">\EName</span>/<span class="keyword">\EName</span>2.in&#125; 与 <span class="keyword">\bfcd</span>&#123;<span class="keyword">\EName</span>/<span class="keyword">\EName</span>2.ans&#125;。</span><br><span class="line"></span><br><span class="line">	该样例约束与测试点2 <span class="built_in">$</span><span class="keyword">\sim</span><span class="built_in">$</span> 5 一致。</span><br><span class="line">	<span class="keyword">\sub</span>&#123;样例 3&#125;</span><br><span class="line">	见选手目录下的 <span class="keyword">\emph</span>&#123;<span class="keyword">\textbf</span>&#123;<span class="keyword">\EName</span>/<span class="keyword">\EName</span>3.in&#125;&#125; 与 <span class="keyword">\emph</span>&#123;<span class="keyword">\textbf</span>&#123;<span class="keyword">\EName</span>/<span class="keyword">\EName</span>3.ans&#125;&#125;。</span><br><span class="line"></span><br><span class="line">	该样例约束与测试点8 <span class="built_in">$</span><span class="keyword">\sim</span><span class="built_in">$</span> 10 一致。</span><br><span class="line">	<span class="keyword">\sub</span>&#123;样例 4&#125;</span><br><span class="line">	见选手目录下的 <span class="keyword">\bfcd</span>&#123;<span class="keyword">\EName</span>/<span class="keyword">\EName</span>4.in&#125; 与 <span class="keyword">\bfcd</span>&#123;<span class="keyword">\EName</span>/<span class="keyword">\EName</span>4.ans&#125;。</span><br><span class="line"></span><br><span class="line">	该样例约束与测试点11 <span class="built_in">$</span><span class="keyword">\sim</span><span class="built_in">$</span> 13 一致。</span><br><span class="line">	<span class="keyword">\sub</span>&#123;样例 5&#125;</span><br><span class="line">	见选手目录下的 <span class="keyword">\bfcd</span>&#123;<span class="keyword">\EName</span>/<span class="keyword">\EName</span>5.in&#125; 与 <span class="keyword">\bfcd</span>&#123;<span class="keyword">\EName</span>/<span class="keyword">\EName</span>5.ans&#125;。</span><br><span class="line"></span><br><span class="line">	该样例约束与测试点17 <span class="built_in">$</span><span class="keyword">\sim</span><span class="built_in">$</span> 20 一致。</span><br><span class="line">	<span class="keyword">\sub</span>&#123;数据范围&#125;</span><br><span class="line">	本题共 <span class="built_in">$</span>25<span class="built_in">$</span> 个测试点，每个测试点 <span class="built_in">$</span>4<span class="built_in">$</span> 分。每个测试点的数据规模和相关限制见下表。</span><br><span class="line"></span><br><span class="line">	<span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">		<span class="keyword">\begin</span>&#123;tabular&#125;&#123; @&#123;&#125;c|c|c|c|c|c@&#123;&#125; &#125;</span><br><span class="line">			<span class="keyword">\Xhline</span>&#123;2pt&#125;</span><br><span class="line">			测试点 <span class="built_in">&amp;</span> <span class="built_in">$</span>n<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span>m<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span>k<span class="built_in">_</span>i<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\sum</span> k<span class="built_in">_</span>i<span class="built_in">$</span> <span class="built_in">&amp;</span> 特殊性质<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\Xhline</span>&#123;1.2pt&#125;</span><br><span class="line">			<span class="built_in">$</span>1<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 5<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 5<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="keyword">\multirow</span>&#123;2&#125;&#123;*&#125;&#123;<span class="built_in">$</span><span class="keyword">\le</span> n<span class="built_in">$</span>&#125; <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 20<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="keyword">\multirow</span>&#123;3&#125;&#123;*&#125;&#123;无&#125;<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\cline</span>&#123;1-3&#125;<span class="keyword">\cline</span>&#123;5-5&#125;</span><br><span class="line">			<span class="built_in">$</span>2<span class="keyword">\sim</span> 5<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 10<span class="built_in">^</span>3<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 10<span class="built_in">^</span>3<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 5<span class="keyword">\times</span> 10<span class="built_in">^</span>3<span class="built_in">$</span><span class="built_in">&amp;</span><span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\cline</span>&#123;1-5&#125;</span><br><span class="line">			<span class="built_in">$</span>6<span class="keyword">\sim</span> 7<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span>=999996<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="keyword">\multirow</span>&#123;3&#125;&#123;*&#125;&#123;<span class="built_in">$</span><span class="keyword">\le</span> 10<span class="built_in">^</span>5<span class="built_in">$</span>&#125; <span class="built_in">&amp;</span> <span class="built_in">$</span>=2<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 2<span class="keyword">\times</span> 10<span class="built_in">^</span>5<span class="built_in">$</span><span class="built_in">&amp;</span><span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\cline</span>&#123;1-2&#125;<span class="keyword">\cline</span>&#123;4-6&#125;</span><br><span class="line">			<span class="built_in">$</span>8<span class="keyword">\sim</span> 10<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span>=999997<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> <span class="keyword">\multirow</span>&#123;5&#125;&#123;*&#125;&#123;<span class="built_in">$</span><span class="keyword">\le</span> n<span class="built_in">$</span>&#125; <span class="built_in">&amp;</span> <span class="keyword">\multirow</span>&#123;3&#125;&#123;*&#125;&#123;<span class="built_in">$</span><span class="keyword">\le</span> 5<span class="keyword">\times</span> 10<span class="built_in">^</span>5<span class="built_in">$</span>&#125;<span class="built_in">&amp;</span>A<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\cline</span>&#123;1-2&#125;<span class="keyword">\cline</span>&#123;6-6&#125;</span><br><span class="line">			<span class="built_in">$</span>11<span class="keyword">\sim</span> 13<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span>=999998<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> <span class="built_in">&amp;</span>B<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\cline</span>&#123;1-3&#125;<span class="keyword">\cline</span>&#123;6-6&#125;</span><br><span class="line">			<span class="built_in">$</span>14<span class="keyword">\sim</span> 16<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span>=999999<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 10<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> <span class="built_in">&amp;</span><span class="keyword">\multirow</span>&#123;3&#125;&#123;*&#125;&#123;无&#125;<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\cline</span>&#123;1-3&#125;<span class="keyword">\cline</span>&#123;5-5&#125;</span><br><span class="line">			<span class="built_in">$</span>17<span class="keyword">\sim</span> 20<span class="built_in">$</span><span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 2<span class="keyword">\times</span> 10<span class="built_in">^</span>5<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 10<span class="built_in">^</span>5<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 10<span class="built_in">^</span>6<span class="built_in">$</span> <span class="built_in">&amp;</span><span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\cline</span>&#123;1-3&#125;<span class="keyword">\cline</span>&#123;5-5&#125;</span><br><span class="line">			<span class="built_in">$</span>21<span class="keyword">\sim</span> 25<span class="built_in">$</span><span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 10<span class="built_in">^</span>6<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 10<span class="built_in">^</span>6<span class="built_in">$</span> <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> <span class="built_in">$</span><span class="keyword">\le</span> 5<span class="keyword">\times</span> 10<span class="built_in">^</span>6<span class="built_in">$</span> <span class="built_in">&amp;</span><span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\Xhline</span>&#123;2pt&#125;</span><br><span class="line">		<span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"></span><br><span class="line">	对于所有数据，保证 <span class="built_in">$</span>1<span class="keyword">\le</span> m,n <span class="keyword">\le</span> 10<span class="built_in">^</span>6<span class="built_in">$</span>，<span class="built_in">$</span>1<span class="keyword">\le</span> k<span class="built_in">_</span>i,u<span class="built_in">_</span>i,v<span class="built_in">_</span>i,p<span class="built_in">_</span>i<span class="keyword">\le</span> n<span class="built_in">$</span>，<span class="built_in">$</span>1<span class="keyword">\le</span> <span class="keyword">\sum</span> k<span class="built_in">_</span>i <span class="keyword">\le</span> 5<span class="keyword">\times</span> 10<span class="built_in">^</span>6<span class="built_in">$</span>，<span class="built_in">$</span>0 <span class="keyword">\le</span> w <span class="keyword">\le</span> 10<span class="built_in">^</span>9<span class="built_in">$</span>。保证图连通，且不存在重边和自环。</span><br><span class="line"></span><br><span class="line">	表中特殊性质栏中变量的含义如下：</span><br><span class="line">	<span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">		<span class="keyword">\tightlist</span></span><br><span class="line">		<span class="keyword">\item</span> A: <span class="built_in">$</span><span class="keyword">\forall</span> i <span class="keyword">\in</span> [1,n),u<span class="built_in">_</span>i=i,v<span class="built_in">_</span>i=i+1<span class="built_in">$</span>。</span><br><span class="line">		<span class="keyword">\item</span> B: <span class="built_in">$</span><span class="keyword">\forall</span> i <span class="keyword">\in</span> [1,n],u<span class="built_in">_</span>i=1<span class="built_in">$</span>。</span><br><span class="line">	<span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line">	<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>NOIP 2021 游记&amp;题解</title>
    <url>/noip2021/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><span id="more"></span>
<p><del>开始口胡</del></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>序列 $s$ 中的 $x$ 满足</p>
<ol>
<li>$x$ 不包含数码 $\texttt{7}$。</li>
<li>$x$ 的所有因数的数码不包含 $\texttt{7}$。</li>
</ol>
<p>有 $T$ 次询问，每次询问给定 $a$，询问 $a$ 在 $s$ 中的后继或返回 $a\in s$。</p>
<p>$1\le a\le 10^7$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>CCF 两年之内最水的签到题，可以类似埃筛的做法直接预处理范围内不满足的数，用二分或预处理每一个数的后继即可。</p>
<p>时间复杂度 $O(n\log n- O(T\log n)$ 或 $O(n\log n)- O(T)$。</p>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>构造一个长度为 $n$，权值范围为 $[0,m]$ 的序列 $a$，设 $S=\sum_i 2^{a_i}$，$S$ 需满足 $\text{popcount}(S)\le k$。</p>
<p>定义一个序列的权值和 $w_a=\prod_i v_{a_i}$。求 $\sum_a w_a$。</p>
<p>$1\le k\le n\le 30$，$1\le m\le 100$。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先考虑暴搜，时间复杂度 $O(m^n)$。期望得分 $20$。</p>
<p>可以剪枝，倒序枚举，若当前状态的 $\text{popcount}(S) &gt; k$ 退出，同时保证序列递减，统计答案时用组合数算一下即可。这里期望得分 $30$。</p>
<hr>
<p>正解是 DP。考虑到每次加一个数时会对 $\text{popcount}$ 产生多少贡献，可以记一个累计进位，多设 $2$ 维状态。</p>
<p>钦定 $a_i$ 单调不降，设 $f(i, j, k, l)$ 表示当前数为 $i$，剩下 $j$ 个数，有 $k$ 个进位，$\text{popcount}$ 为 $l$。 则有<br>$$<br>f(i + 1, j - x, \dfrac{k + x}2, l + (x + y) \bmod 2)=\sum_{x=1}^j f(i, j, k, l) \times \dbinom{j}{x}\times v_i^x<br>$$<br>时间复杂度 $O(n^4m)$。</p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定序列 $a$，一次操作可以选取 $i\in(1,n)$，将 $a_i\gets a_{i - 1} + a_{i + 1} - a_i$。问经过若干次操作后，$a$ 方差的最小值。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先考虑乱搞，由于只有单组数据，可以用模拟退火求最优值。期望得分 ？。</p>
<hr>
<p>首先要知道这个操作的意义，考虑将 $a$ 映射到数轴上，一次操作相当于将 $a_i$ 对 $(a_{i-1},a_{i+1})$ 的中点做一次对称操作，即两端距离仍未改变。则问题转化为所有线段经过一系列交换之后，使得端点的方差最小。</p>
<p>那么显然，方差最小指所有数离平均数的距离更近，则自然可得这些线段的长度构成一个<strong>单谷</strong>，即先降后升。</p>
<p>至此，我们可以将所有线段的长度降序排序，考虑每个线段放在左端或右端，时间复杂度 $O(2^n\times n)$。</p>
<p>再次考虑 DP，设 $f(i, \sum_i a_i)=\min\{\sum_i a_i^2\}$。表示当前枚举到第 $i$ 条线段的状态。则有<br>$$<br>f(i + 1, \sum_i a_i+x)=f(i,\sum_i a_i)+x^2<br>$$<br>$$<br>f(i + 1, \sum_i a_i + i \times x)=f(i, \sum_i a_i)+2\sum_i a_i \times x+x^2i<br>$$</p>
<p>分别表示当前线段放在左边或右边的贡献。</p>
<p>时间复杂度 $O(nm\min\{n,m\})$。</p>
<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>$x^n+y^n=z^n$</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先依题意模拟有 $24$ 分。</p>
<p>先考虑走空格的贡献，注意到 $1$ 道路可以特判，$2$ 道路可以直接维护一个点所能走到的范围，$3$ 道路可以用并查集维护一个联通块。但是加上一个点相当于将一个联通块分裂，不易维护。可以倒序处理每一个点，每次将几个连通块合并即可。</p>
<p>其次考虑重复的贡献，需要用一个数据结构维护一段线段在联通块之内的贡献。</p>
<p>再次考虑棋子的贡献，可以维护每一个联通块能达到的点集，与上种贡献类似。</p>
<p>至此，我们需要一个数据结构支持合并和查询一段区间信息，可以用线段树合并实现。</p>
<p>时间复杂度 $O(nm\log nm)$。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><del>口胡结束</del></p>
]]></content>
  </entry>
  <entry>
    <title>PKUSC &amp; PKUWC 2018 选解</title>
    <url>/pku-2018/</url>
    <content><![CDATA[<h2 id="Winter-Camp-Min-Max"><a href="#Winter-Camp-Min-Max" class="headerlink" title="Winter Camp Min-Max"></a>Winter Camp Min-Max</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定 $n$ 个节点的二叉树，给定叶节点的权值，非叶节点的权值有 $p$ 的概率为子节点的最大值，否则为子节点的最小值。</p>
<p>求根节点取到任意值的概率。</p>
<p>$1\le n\le 3\times 10^5$。</p>
<span id="more"></span>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑 DP，设 $f(i,j)$ 表示 $i$ 节点选到 $j$ 的概率，可以从子节点 $l,r$ 转移，有<br>$$<br>f(i,j)=f(l,j)\left(p_i\sum_{k=1}^{j-1}f(r,k)+(1-p_i)\sum^{m}_{k=j+1}f(r,k)\right)+f(r,j)\left(p_i\sum_{k=1}^{j-1}f(l,k)+(1-p_i)\sum^{m}_{k=j+1}f(l,k)\right)<br>$$<br>这样直接转移是 $\mathcal O(n^2)$ 的，考虑优化。</p>
<p>注意到这些和式都是前缀或后缀和的形式，显然可以在 DFS 的过程中用线段树合并优化，时间复杂度 $\mathcal{O}(n\log n)$。细节较多，可以参见代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ls[maxN &lt;&lt; <span class="number">5</span>], rs[maxN &lt;&lt; <span class="number">5</span>], tol;</span><br><span class="line">	Z val[maxN &lt;&lt; <span class="number">5</span>], mul[maxN &lt;&lt; <span class="number">5</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		val[x] = val[ls[x]] + val[rs[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mul[x].x == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (ls[x]) mul[ls[x]] *= mul[x], val[ls[x]] *= mul[x];</span><br><span class="line">		<span class="keyword">if</span> (rs[x]) mul[rs[x]] *= mul[x], val[rs[x]] *= mul[x];</span><br><span class="line">		mul[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, Z w)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!x) mul[x = ++tol] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> val[x] = w, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">		<span class="built_in">Pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid) <span class="built_in">Update</span>(ls[x], l, mid, p, w);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">Update</span>(rs[x], mid + <span class="number">1</span>, r, p, w);</span><br><span class="line">		<span class="built_in">PushUp</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, Z wx, Z wy, Z w)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x + y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">			mul[y] *= wy, val[y] *= wy;</span><br><span class="line">			<span class="keyword">return</span> y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">			mul[x] *= wx, val[x] *= wx;</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Pushdown</span>(x); <span class="built_in">Pushdown</span>(y);</span><br><span class="line">		Z lsx = val[ls[x]], rsx = val[rs[x]], lsy = val[ls[y]], rsy = val[rs[y]];</span><br><span class="line">		ls[x] = <span class="built_in">Merge</span>(ls[x], ls[y], l, mid, wx + (<span class="number">1</span> - w) * rsy, wy + (<span class="number">1</span> - w) * rsx, w);</span><br><span class="line">		rs[x] = <span class="built_in">Merge</span>(rs[x], rs[y], mid + <span class="number">1</span>, r, wx + w * lsy, wy + w * lsx, w);</span><br><span class="line">		<span class="built_in">PushUp</span>(x);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Z <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> a[l] * val[x] * val[x] * l;</span><br><span class="line">		<span class="built_in">Pushdown</span>(x);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Query</span>(ls[x], l, mid) + <span class="built_in">Query</span>(rs[x], mid + <span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; st;</span><br><span class="line"><span class="keyword">int</span> n, m, son[maxN][<span class="number">2</span>], cnt[maxN], rt[maxN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cnt[x]) <span class="keyword">return</span> st.<span class="built_in">Update</span>(rt[x], <span class="number">1</span>, m, w[x].x, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">DFS</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> (cnt[x] == <span class="number">1</span>) rt[x] = rt[son[x][<span class="number">0</span>]];</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">DFS</span>(son[x][<span class="number">1</span>]), rt[x] = st.<span class="built_in">Merge</span>(rt[son[x][<span class="number">0</span>]], rt[son[x][<span class="number">1</span>]], <span class="number">1</span>, m, <span class="number">0</span>, <span class="number">0</span>, w[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	io &gt;&gt; n &gt;&gt; son[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, p; i &lt;= n; i++) &#123;</span><br><span class="line">		io &gt;&gt; p;</span><br><span class="line">		son[p][cnt[p]++] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) io &gt;&gt; x, w[i] = x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cnt[i] &gt; <span class="number">0</span>) w[i] *= <span class="number">796898467</span>;</span><br><span class="line">		<span class="keyword">else</span> a.<span class="built_in">emplace_back</span>(w[i].x);</span><br><span class="line">	&#125;</span><br><span class="line">	std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	m = a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) w[i] = std::<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), w[i].x) - a.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line">	io &lt;&lt; st.<span class="built_in">Query</span>(rt[<span class="number">1</span>], <span class="number">1</span>, m).x;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Winter-Camp-随机游走"><a href="#Winter-Camp-随机游走" class="headerlink" title="Winter Camp 随机游走"></a>Winter Camp 随机游走</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定 $n$ 个节点的树，$Q$ 次询问，每次给出一个点集 $S$，求从 $x$ 出发随机游走经过点集中的所有点的期望步数。</p>
<p>$n\le 18$，$Q\le 5\times 10^3$。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先注意到，题目要求<strong>经过所有点</strong>，不妨考虑 min-max 容斥，即转化为<strong>至少经过一个点</strong>的期望步数，有<br>$$<br>E(\max(S))=\sum_{T\subseteq S}(-1)^{|T|+1}E(\min(T))<br>$$<br>转化后，考虑 DP，设 $f(S,u)$ 表示从 $u$ 出发，经过 $S$ 中至少一个点的期望步数，显然当 $u\in S$ 时，$f(S,u)=0$。当 $u\notin S$ 时，有转移<br>$$<br>f(S,u)=\frac{1}{d_u}\left(f(S,fa_u)+\sum_{v\in son(u)}f(S,v)\right)+1<br>$$<br>其中 $d_u$ 表示点 $u$ 的度数。</p>
<p>显然这个 DP 有后效性，可以高斯消元解决。但这是一个树上问题，考虑从父亲转移到儿子，设 $f(u)=a_uf(fa_u)+b_u$（将 $f(S,u)$ 简写成 $f(u)$，下同），带入上式可得<br>$$<br>\begin{aligned}<br>f(u)&amp;=\frac 1{d_u}\left(f(fa_u)+\sum_{v\in son(u)}a_vf(u)+b_v\right)\\<br>&amp;=\frac 1{d_u}\left(f(fa_u)+\text{sum}a_uf(u)+\text{sum}b_u\right)<br>\end{aligned}<br>$$<br>把未知项移到左边，有<br>$$<br>(d_u-\text{sum}a_u)f(u)=f(fa_u)+\text{sum}b_u<br>$$<br>整理得到<br>$$<br>f(u)=\frac{1}{d_u-\text{sum}a_u}f(fa_u)+\frac{\text{sum}b_u}{d_u-\text{sum}a_u}<br>$$<br>即<br>$$<br>a_u=\frac{1}{d_u-\text{sum}a_u}\quad b_u=\frac{\text{sum}b_u}{d_u-\text{sum}a_u}<br>$$<br>答案 $f(x)$ 不能从父亲转移，即 $f(x)=b_x$。</p>
<p>这部分的时间复杂度为 $\mathcal{O}(2^nn\log \bmod)$。</p>
<p>至此，我们求得了 $(-1)^{|T|+1}\min(T)$，接下来的问题即求子集和，可以直接对 $f$ 做一次 FWT，即可做到 $\mathcal{O}(1)$ 查询。</p>
<blockquote>
<p>Tip：为什么这样做是对的？</p>
<p>考虑或卷积 $c_i=\sum_{i=j|k}a_jb_k$</p>
<p>设 $\hat a=\mathcal F a$ 表示 $a$ 的 FWT，根据或卷积的 FWT 为乘积，得到 $\hat c_i=\hat a_i\hat b_i$。而或运算相当于子集求并，则 $i$ 的子集都会对 $\hat a_i$ 产生贡献，即 $\hat a_i=\sum_{j\subseteq i}a_j$</p>
</blockquote>
<p>总时间复杂度为 $\mathcal{O}(2^nn\log \bmod+\sum |S|)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, Q, rt;</span><br><span class="line">io &gt;&gt; n &gt;&gt; Q &gt;&gt; rt; rt--;</span><br><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">e</span>(n);</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">deg</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;Z&gt; <span class="title">f</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class="line">	io &gt;&gt; u &gt;&gt; v; --u; --v;</span><br><span class="line">	++deg[u]; ++deg[v];</span><br><span class="line">	e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">	e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++s) &#123;</span><br><span class="line">	<span class="function">std::vector&lt;Z&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">	std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; DFS = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s &gt;&gt; u &amp; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		Z _a, _b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">DFS</span>(v, u);</span><br><span class="line">			_a += a[v], _b += b[v];</span><br><span class="line">		&#125;</span><br><span class="line">		a[u] = <span class="built_in">Z</span>(<span class="number">1</span>) / (<span class="built_in">Z</span>(deg[u]) - _a);</span><br><span class="line">		b[u] = a[u] * (<span class="built_in">Z</span>(_b) + deg[u]);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">DFS</span>(rt, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (__builtin_popcount(s) &amp; <span class="number">1</span>) f[s] += b[rt];</span><br><span class="line">	<span class="keyword">else</span> f[s] -= b[rt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j += (<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>)))</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; i); ++k)</span><br><span class="line">			f[j | k | (<span class="number">1</span> &lt;&lt; i)] += f[j | k];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k, u; Q--;) &#123;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (io &gt;&gt; k; k--;) &#123;</span><br><span class="line">		io &gt;&gt; u;</span><br><span class="line">		s |= (<span class="number">1</span> &lt;&lt; (u - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	io &lt;&lt; f[s].x &lt;&lt; <span class="string">&quot;\\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Winter-Camp-猎人杀"><a href="#Winter-Camp-猎人杀" class="headerlink" title="Winter Camp 猎人杀"></a>Winter Camp 猎人杀</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 $n$ 个猎人，第 $i$ 个人的权值为 $w_i$，依次对猎人射击，第 $i$ 个人被击杀的概率是 $\frac{w_i}{\sum_{k\in S}w_k}$，其中 $S$ 表示当前存活猎人的集合。</p>
<p>求 $n-1$ 次射杀后，一号猎人存活的概率。</p>
<p>$\sum w\le 10^5$。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>考虑一次射击时假定所有人都活着，一直打，直到打到了确实活的人为止，这样做显然对最终的答案没有影响（活人之间的概率比没有改变）。</p>
<p>则考虑容斥，设 $f(S)$ 表示 $S$ 中的人都死在 $1$ 之后的概率，即开无限枪，不能打到 $S\cup\{1\}$ 中的人，直到打到 $1$ 为止。则<br>$$<br>f(S)=\sum_{i\ge 0}\left(\frac{\sum_{k\in (U\setminus (S\cup\{1\}))}w_k}{\sum w}\right)^i\frac{w_1}{\sum w}<br>$$<br>根据等比数列求和公式，得到<br>$$<br>f(S)=\frac{1-\lim\limits_{x\to \infty}\left(\frac{\sum_{k\in (U\setminus (S\cup\{1\}))}w_k}{\sum w}\right)^x}{1-\frac{\sum_{k\in (U\setminus (S\cup\{1\}))}w_k}{\sum w}}\frac{w_1}{\sum w}=\frac{1}{\frac{\sum_{k\in (S\cup\{1\})}w_k}{\sum w}}\frac{w_1}{\sum w}=\frac{w_1}{\sum_{k\in (S\cup\{1\})}w_k}<br>$$<br>则答案为<br>$$<br>\sum_{S\subseteq U\setminus\{1\}}(-1)^{|S|}\frac{w_1}{\sum_{k\in (S\cup\{1\})}w_k}<br>$$<br>注意到数据范围中限制了 $\sum w$，考虑枚举这个东西，即求<br>$$<br>\sum_{i=0}^{\sum w-w_1}\frac{w_1}{i+w_1}\sum_{\sum_{k\in S}w_k=i}(-1)^{|S|}<br>$$<br>右半部分是非常棘手的，但理智分析一下可以发现，右边的和式即<br>$$<br>[x^i]\prod_{i=2}^n 1-x^{w_i}<br>$$<br>感性理解一下，对于奇数个元素的集合，其对答案的贡献是 $-1$，而奇数个 $-x$ 相乘，其系数也为 $-1$，偶数同理。</p>
<p>至此，这个积式可以分治加 NTT 在 $\mathcal O(n\log ^2n)$ 求得，总时间复杂度为 $\mathcal O(n+\sum w\log^2\sum w)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">io &gt;&gt; n;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) io &gt;&gt; w[i];</span><br><span class="line">std::function&lt;<span class="built_in">Poly</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; Solve= [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; Poly &#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		Poly _(w[l] + <span class="number">1</span>);</span><br><span class="line">		_[<span class="number">0</span>] = <span class="number">1</span>; _[w[l]] = P - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> _;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	Poly a = <span class="built_in">Solve</span>(l, mid), b = <span class="built_in">Solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line">Poly f = <span class="built_in">Solve</span>(<span class="number">2</span>, n);</span><br><span class="line"><span class="keyword">int</span> s = std::<span class="built_in">accumulate</span>(w.<span class="built_in">begin</span>(), <span class="built_in">wend</span>(), <span class="number">0</span>);</span><br><span class="line">Z ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) ans += f[i] * w[<span class="number">1</span>] / (w[<span class="number">1</span>] + i);</span><br><span class="line">io &lt;&lt; ans.x;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Summer-Camp-神仙的游戏"><a href="#Summer-Camp-神仙的游戏" class="headerlink" title="Summer Camp 神仙的游戏"></a>Summer Camp 神仙的游戏</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定由 $\texttt{0 1 ?}$ 组成的字符串 $s$，$\texttt{?}$ 可以任意替换成 $\texttt{0}$ 或 $\texttt{1}$。求在替换过后，$\forall i\in [1,n]$，长度为 $i$ 的前缀能否成为 border。</p>
<p>$|s|\le 5\times 10^5$。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>一个长度为 $p$ 的前缀为 border $\iff \forall[1,p],s_i=s_{|s|-p+i}\iff \forall i,j\in [1,n]\land i\equiv j\pmod{n-p},s_i=s_j\iff \forall i,j\in [1,n]\land |i-j|\ |n-p, s_i=s_j$</p>
]]></content>
  </entry>
  <entry>
    <title>USACO 2007 January Gold T3 Cow School Solution</title>
    <url>/usaco-07-g3/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 $n$ 次考试，第 $i$ 次的满分为 $b_i$，你的得分为 $a_i$，你可以删去 $d$ 次考试，从而你最后的分数为剩下的得分与剩下的总分之比，现存在一种方案，即删去 $\dfrac{a_i}{b_i}$ 最小的 $d$ 次考试，你可以任意删去 $d$ 个考试，求所有的 $d$，使得存在一个最后分数更高的方案。</p>
<p>$n\le 5\times 10^4$。</p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>显然可以对所有考试排序预处理出每个 $d$ 的原始方案所得分数 $\dfrac{S_d}{T_d}$。</p>
<p>考虑暴力，如果一个 $d$ 合法，则可以找到 $n-d$ 次考试，使得 $\dfrac{\sum a_{p_i}}{\sum b_{p_i}}&gt;\dfrac{S_d}{T_d}$，其中 $p$ 表示一个方案的的下标集合。</p>
<p>问题转化为求 $\max\left\{\dfrac{\sum a_{p_i}}{\sum b_{p_i}}\right\}$，可以用 0/1 分数规划 + 0/1 背包在 $O(n^2\log n)$ 的时间复杂度下解决。</p>
<p>更进一步，如果一个 $d$ 合法，则可以在原始方案中替换一个 $i$ 变为 $j$，其中 $i\le d &lt; j\le n$，使得方案更优，即 $\dfrac{S_d-a_i+a_j}{T_d-a_i+a_j}&gt;\dfrac{S_d}{T_d}$，化简得  $b_iS_d-a_iT_d&lt; b_jS_d-a_jT_d$，设<br>$$<br>f(d)=\min\{b_iS_d-a_iT_d\}(1\le i\le d)<br>$$<br>$$<br>g(d)=\max\{b_iS_d-a_iT_d\}(d&lt; i\le n)<br>$$<br>则 $d$ 可以作为一个合法方案，当且仅当 $f(d)&lt; g(d)$，可以 $O(n^2)$ 枚举解决。</p>
<p>考虑优化，发现这个式子很像斜率优化。</p>
<p>以 $f(d)$ 为例，原式可化为 $\dfrac{f(d)}{S_d}=\min\left\{b_i-\dfrac{T_d}{S_d}a_i\right\}$。</p>
<p>这里 $b=\dfrac{f(d)}{S_d}, y=b_i, k=\dfrac{T_d}{S_d}, x=a_i$。即 $b=\min\{y-kx\}$，可以维护一个下凸包，以保证决策最优。</p>
<p>与一般的斜率优化不同的是，这题的横坐标 $x$ 并不是递增的，即无法直接通过一般的数据结构（单调队列，单调栈）维护，这里通过 CDQ 分治维护。</p>
<p>在分治时维护凸包，先保证左半部分的横坐标 $x$ 递增（用归并排序保证时间复杂度），计算左半部分的凸包对右半部分的 $f(d)$ 的影响，不断向下递归即可解决问题。</p>
<p>最后，考虑 $k=\dfrac{T_d}{S_d}$ 的单调性。可以先证明 $\dfrac{b_1}{a_1}&gt;\dfrac{b_1+b_2}{a_1+a_2}$（因为我们对考试进行了排序，即保证了 $\dfrac{a_i}{b_i}&lt; \dfrac{a_j}{b_j}(i&lt; j)$），然后用数学归纳法可以得出 $\dfrac{T_d}{S_d}$ 单调递减。根据斜率优化的基本操作，计算 $f$ 时用单调栈维护凸包，计算 $g$ 时用单调栈维护，即可在 $O(n\log n)$ 的时间复杂度下解决问题。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, S[MAXN], T[MAXN], q[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node A) &#123;<span class="keyword">return</span> <span class="number">1.0</span> * a / b &lt; <span class="number">1.0</span> * A.a / A.b;&#125;</span><br><span class="line">&#125; p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span><span class="keyword">int</span> x, y;&#125; Q[MAXN], tmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q[i].x == Q[j].x) <span class="keyword">return</span> Q[i].y &lt; Q[j].y ? <span class="number">1e18</span> : <span class="number">-1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (Q[i].y - Q[j].y) / (Q[i].x - Q[j].x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">solve_f</span>(l, mid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">slope</span>(q[R - <span class="number">1</span>], q[R]) &gt; <span class="built_in">slope</span>(q[R], i)) R--;</span><br><span class="line">        q[++R] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">slope</span>(q[R - <span class="number">1</span>], q[R]) &gt; <span class="number">1.0</span> * T[i] / S[i]) R--;</span><br><span class="line">        f[i] = std::<span class="built_in">min</span>(f[i], <span class="number">1ll</span> * Q[q[R]].y * S[i] - <span class="number">1ll</span> * Q[q[R]].x * T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve_f</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, p1 = l, p2 = mid + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span> (p2 &gt; r || (p1 &lt;= mid &amp;&amp; Q[p1].x &lt; Q[p2].x)) tmp[i] = Q[p1++];</span><br><span class="line">        <span class="keyword">else</span> tmp[i] = Q[p2++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) Q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_g</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, R = <span class="number">0</span>, L = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve_g</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; <span class="built_in">slope</span>(q[R - <span class="number">1</span>], q[R]) &lt; <span class="built_in">slope</span>(q[R], i)) R--;</span><br><span class="line">        q[++R] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; <span class="built_in">slope</span>(q[L], q[L + <span class="number">1</span>]) &gt; <span class="number">1.0</span> * T[i] / S[i]) L++;</span><br><span class="line">        g[i] = std::<span class="built_in">max</span>(g[i], <span class="number">1ll</span> * Q[q[L]].y * S[i] - <span class="number">1ll</span> * Q[q[L]].x * T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve_g</span>(l, mid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, p1 = l, p2 = mid + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span> (p2 &gt; r || (p1 &lt;= mid &amp;&amp; Q[p1].x &lt; Q[p2].x)) tmp[i] = Q[p1++];</span><br><span class="line">        <span class="keyword">else</span> tmp[i] = Q[p2++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) Q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">read</span>(p[i].a, p[i].b);</span><br><span class="line">    std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) S[i] = S[i + <span class="number">1</span>] + p[i + <span class="number">1</span>].a, T[i] = T[i + <span class="number">1</span>] + p[i + <span class="number">1</span>].b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) Q[i] = Query&#123;p[i].a, p[i].b&#125;, f[i] = <span class="number">1ll</span> * p[i].b * S[i] - <span class="number">1ll</span> * p[i].a * T[i];</span><br><span class="line">    <span class="built_in">solve_f</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0xcf</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) Q[i] = Query&#123;p[i].a, p[i].b&#125;;</span><br><span class="line">    <span class="built_in">solve_g</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (f[i] &lt; g[i]) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">write</span>(ans.<span class="built_in">size</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> res : ans) <span class="built_in">write</span>(res, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Luogu 7526</title>
    <url>/xor-problem/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定 $n$ 个数 $a_i$，对于每一个 $i\in[0,K-1]$，求选出 $m$ 个数使得异或和为 $i$ 的方案数。</p>
<p>$m\le n\le 1.3\times 10^5, a_i&lt;K\le 2^{17}$。</p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设 $\mathcal F:\mathbb R^K\to\mathbb R^K$ 表示异或的沃尔什变换，设答案的形式幂级数为 $G$，$a_i$ 的形式幂级数为 $F_i$，$a$ 的形式幂级数为 $A$，则<br>$$<br>\mathcal F(G)[k]=\sum_{S\subset [n],|S|=m}\prod_{i\in S}\mathcal F(F_i)[k]=\sum_{S\subset [n],|S|=m}\prod_{i\in S}\mathcal (-1)^{|a_i\cap k|}<br>$$<br>注意到右边的和式只与 $\mathcal F(A)[k]$ 相关，考虑对于任意 $k$，令<br>$$<br>\mathcal F(A)[k]=\sum_{i=0}^{K-1}(-1)^{|i\cap k|}A[i]=c_1-c_2<br>$$<br>其中 $c_1$ 表示 $(-1)^{|i\cap k|}$ 取到 $1$ 时的和，$c_2$ 表示取到 $-1$ 的和，显然有 $c_1+c_2=n$。则原答案右边的和式对答案有正的贡献当且仅当从 $c_1$ 选一些数，$c_2$ 中选一些数，其中从 $c_2$ 选的数的个数一定是偶数，且一共选了 $m$ 个数，写成生成函数即为<br>$$<br>[x^m] (1+x)^{c_1}(1-x)^{n-c_1}<br>$$<br>展开得到<br>$$<br>[x^m]\sum_{i=0}^{c_1}\binom{c_1}{i}x^i\sum_{j=0}^{n-c_1}\binom{n-c_1}{j}(-1)^{n-c_1-j}x^{n-c_1-j}<br>$$<br>套路交换枚举顺序，有<br>$$<br>\begin{aligned}<br>&amp;[x^m]\sum_{i=0}^nx^i\sum_{j=0}^{\min\{c_1,i\}}\binom{c_1}{j}\binom{n-c_1}{i-j}(-1)^{n-c_1-i+j}\\<br>=&amp;\sum_{i=0}^{\min\{c_1,m\}}\binom{c_1}{i}\binom{n-c_1}{m-i}(-1)^{n-c_1-m+i}\\<br>=&amp;(c_1)!(n-c_1)!\sum_{i=0}^{\min\{c_1,m\}}\frac{(-1)^{n-c_1-m+i}}{i!(c_1-i)!(m-i)!(n-c_1-m+i)!}<br>\end{aligned}<br>$$<br>NTT 不难解决，时间复杂度 $\mathcal O(n\log n+K\log K)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, K;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; K;</span><br><span class="line"><span class="function">std::vector&lt;Int&gt; <span class="title">fac</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">inv</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = fac[i - <span class="number">1</span>] * i;</span><br><span class="line">inv[n] = <span class="built_in">Int</span>(<span class="number">1</span>) / fac[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) inv[i - <span class="number">1</span>] = inv[i] * i;</span><br><span class="line"><span class="function">Poly <span class="title">a</span><span class="params">(m + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(n - m + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">	a[i] = inv[i] * inv[m - i];</span><br><span class="line">	<span class="keyword">if</span> ((m - i) &amp; <span class="number">1</span>) a[i] = Mod - a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; ++i) b[i] = inv[i] * inv[n - m - i];</span><br><span class="line">a = a * b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) a[i] *= fac[i] * fac[n - i];</span><br><span class="line"><span class="function">std::vector&lt;Int&gt; <span class="title">f</span><span class="params">(K)</span>, <span class="title">g</span><span class="params">(K)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; ++i) std::cout &gt;&gt; x, f[x] += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">FWT</span>(f, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) g[i] = a[(n + f[i]) / <span class="number">2</span>];</span><br><span class="line"><span class="built_in">FWT</span>(g, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) std::cout &lt;&lt; g[i].x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<p><del>剩下的 2 分就要各显神通了</del></p>
]]></content>
  </entry>
  <entry>
    <title>BZOJ3309 Solution</title>
    <url>/BZOJ3309/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于 $n$ 的唯一分解 $n=\prod p^c$，定义 $f(n)=\max\{c\}$。</p>
<p>$T$ 组询问，给定 $n,m$，求<br>$$<br>\sum_{i=1}^n\sum_{i=1}^mf(\gcd(i,j))<br>$$<br>$T\le 10^4$，$n,m\le 10^7$</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑莫比乌斯反演，原式可化为<br>$$<br>\sum_{d=1}^nf(d)\sum_{i=1}^{\left\lfloor\frac nd\right\rfloor}\sum_{i=1}^{\left\lfloor\frac md\right\rfloor}[\gcd(i,j)=1]<br>$$<br>$$<br>\sum_{d=1}^nf(d)\sum_{x|d}\mu(x)\left\lfloor\frac {n}{dx}\right\rfloor\left\lfloor\frac {m}{dx}\right\rfloor<br>$$<br>$$<br>\sum_{T=1}^n\left\lfloor\frac nT\right\rfloor\left\lfloor\frac mT\right\rfloor\sum_{d|T}f(d)\mu\left(\frac Td\right)<br>$$<br>令<br>$$<br>g(n)=\sum_{d|n}f(d)\mu\left(\frac nd\right)<br>$$<br>将 $n,d$ 唯一分解 $n=\prod\limits_{i=1}^kp_i^{x_i},d=\prod\limits_{i=1}^kp_i^{y_i}$。则 $\mu\left(\dfrac nd\right)$ 取到非零值当且仅当<br>$$<br>\forall i\in[1,k],y_i-x_i\le 1<br>$$<br>设 $a=\max\{c_i\}$，则 $f(d)=a$ 或 $f(d)=a-1$。</p>
<p>当 $f(d)=a$ 时，设有 $q$ 个质因数的指数为 $a$，则<br>$$<br>g(n)=a\sum_{d|n}\mu\left(\frac nd\right)=a\sum_{i=1}^q\binom{q}{i}(-1)^{q-i}\sum_{j=0}^{k-q}\binom{k-q}{j}(-1)^j<br>$$</p>
<ul>
<li><p>当 $k-q\neq0$，$g(n)=0$。</p>
</li>
<li><p>当 $k-q=0$，即 $k=q$ 时<br>$$<br>g(n)=a\sum_{i=1}^k\binom{k}{i}(-1)^{k-i}=a\left(\sum_{i=0}^k\binom{k}{i}(-1)^{k-i}-(-1)^k\right)=(-1)^{k+1}a<br>$$<br>当 $f(d)=a-1$ 时，同理得到</p>
</li>
<li><p>当 $k-q\neq0$ 时，$g(n)=0$</p>
</li>
<li><p>当 $k-q=0$ 时，$g(n)=(1-a)(-1)^{k+1}$</p>
</li>
</ul>
<p>故<br>$$<br>g(n)=\begin{cases}<br>(-1)^{k+1}&amp;k=q\\<br>0&amp;k\neq q<br>\end{cases}<br>$$<br>原式<br>$$<br>\sum_{T=1}^n\left\lfloor\frac nT\right\rfloor\left\lfloor\frac mT\right\rfloor g(T)<br>$$<br>可以数论分块简单解决。</p>
<p>考虑如何筛出 $g$，考虑 $k=q=1$ 的情况，此时与 $\mu$ 类似，可以直接线筛，对于 $k&gt;1$ 的部分可以 $O(n\ln n)$ 小常数枚举。总时间复杂度 $O(n\ln n+T\sqrt n)$。</p>
]]></content>
  </entry>
</search>
